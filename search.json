[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Quantum Technology",
    "section": "",
    "text": "Preface\nThe goal for this text is to be a snapshot in time of quantum technologies: the good, the bad, and the ugly. As of 2024, there has been a large amount of industry interest and progress to develop quantum technologies, and a student approaching this industry should have the basic knowledge to understand what is trying to be achieved and how they are trying to achieve it. To cut through the PR of industry, this text offers the author’s personal perspective on what has been achieved, where things need to go, and the challenges to get there. This is not meant to be an authoritative guide on any one of the technologies presented here, but a jumping off point for the interested student.\nFinally, this is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "1.1 The Quantum-Classical Arms Race\nIn 2019  [1], Google reached a significant milestone in quantum computing when they achieved “Quantum Advantage”–demonstrating for the first time that a quantum computer could surpass the capabilities of classical computers, albeit for a specific, specialized task. Using their Sycamore processor with 53 qubits, they showed that sampling from a quantum circuit a million times took only 200 seconds, while the equivalent task would take approximately 10,000 years on a classical supercomputer. This breakthrough marked a turning point in quantum computing, igniting increased interest and investment in quantum technologies. Building on this success, in December 2024, Google announced their new Willow chip  [2], representing their latest advancement in quantum hardware. Today, numerous companies and research institutions worldwide are racing to develop quantum hardware, each pursuing different technological approaches to challenge the computational limits of classical computers.\nThis text aims to give undergraduate students a comprehensive introduction to quantum technology and computation. We will begin by exploring the fundamental mathematical framework that underlies quantum computing, building from basic principles to more advanced concepts. Crucially, we will see what specific things a quantum computer can achieve that a classical computer would struggle with. With this foundation, we will examine three of the most promising current quantum computing technologies: superconducting qubits, photonic quantum computing, and ion traps. Each of these approaches offers unique advantages and faces distinct challenges, which we will analyze in detail.\nTo bridge theory with practice, we will utilize IBM’s Qiskit software platform to implement basic quantum computations, providing hands-on experience with quantum programming. As we progress, we will explore critical practical considerations in quantum computing, including error mitigation and correction strategies. Time permitting, we will venture into the cutting-edge field of topological quantum computing, which offers a potentially more robust approach to quantum computation.\nThroughout this text, we will maintain a balanced perspective, examining both the tremendous potential and significant challenges facing quantum computing technology. Our goal is to equip students with both theoretical understanding and practical insights into this rapidly evolving field.\nThe story of Google’s quantum supremacy claim illustrates a fascinating dynamic in the field of quantum computing–an ongoing arms race between quantum and classical algorithms. When Google first announced their achievement with the Sycamore processor  [1], they estimated that their quantum sampling task would take a classical supercomputer approximately 10,000 years. However, within months, IBM researchers developed improved classical algorithms that could potentially perform the same calculation in just 2.5 days  [3]. Further work even demonstrated that using tensor networks, the problem could be solved faster on a modern superconductor with ExaFLOPS performance  [4].\nThis back-and-forth highlights several important lessons. First, it demonstrates the remarkable adaptability of classical computing. As quantum computers advance, classical algorithm developers find increasingly clever ways to simulate quantum systems or solve specific problems more efficiently. This competition drives innovation in both fields–quantum hardware must continually improve to maintain its advantage, while classical algorithms become more sophisticated in response.\nSecond, it serves as a cautionary tale about interpreting quantum computing announcements, particularly those aimed at the general public. While the achievement of quantum advantage represents a genuine milestone, the initial 10,000-year estimate proved overly optimistic. This pattern has repeated with various quantum computing companies, where marketing claims sometimes outpace peer-reviewed scientific validation. For students and researchers in the field, it’s crucial to maintain a balanced perspective–acknowledging genuine breakthroughs while critically evaluating bold claims.\nThe recent announcement of Google’s Willow chip  [2] represents another step forward, but should be viewed within this context of ongoing competition and careful validation. This healthy tension between quantum and classical approaches ultimately benefits both fields, pushing the boundaries of what’s computationally possible while maintaining rigorous scientific standards.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#sec-transistors",
    "href": "intro.html#sec-transistors",
    "title": "1  Introduction",
    "section": "1.2 Early Computing: The Lesson of Transistors",
    "text": "1.2 Early Computing: The Lesson of Transistors\nIn Ref.  [5] there are a few quotes about early computing\n\n“Computers in the future may weigh no more than 1.5 tons.” –Popular Mechanics, forecasting the relentless march of science, 1949\n\n\n“I think there is a world market for maybe five computers.” –Thomas Watson, chairman of IBM, 1943\n\nThese quotes raise important points about early technology. While the theory of modern computing really took off with Turing in 1937  [6], the technological advancement necessary for modern computurs would not occur until later: when the transistor came about.\n\n1.2.1 The Dream: Field Effect Transistors\n\n\n\n\n\n\n\n\n\n\n\n(a) P-channel\n\n\n\n\n\n\n\n\n\n\n\n(b) N-channel\n\n\n\n\n\n\n\nFig. 1.1: Example Circuit diagrams for MOSFETs (enh)\n\n\n\nTo enable classical computing, we need something like a “switch” that can be on and off, keeping track of whether or not something like, current is flowing. This is hard to do with traditional circuit elements like resistors, capacitors, and inductors. It requires something more nonlinear: A switch that only allows current flow when a voltage is applied, a transistor.\nFig. 1.1 shows two of the types of circuit diagrams for a bipolar junction transistor (G = gate, S = source, and D = drain)1. A voltage applied at the gate enables a larger current to flow between collector and emitter. There are also bipolar junction transistors that use a smaller current to enable a larger current, in this case there is “base”, “collector”, and “emitter”.\nWith these building blocks, logical gates can be created, but how to build these? Which device can be made small and in abundance? And what challenges were encountered on the way.\n\n\n\n\n\n\nScale of Modern Computing in your pocket\n\n\n\nThe iPhone A17 Pro chip’s 19 billion transistors would cover an area of about 1 square centimeter. If each transistor were the size of a grain of rice, they would cover an area larger than 75 football fields! This incredible miniaturization is what enables modern computing.\n\n\nIt was recognized early on that semiconductors provided an ideal platform for these kinds of circuits, and much work was done to try and create the above “field effect transistors.” Schematically, these take the form:\n\n\n\n\n\n\nFig. 1.2: Schematic of Field Effect Transistor2\n\n\n\nIn Fig. 1.2, electrons flow from source to drain, but only when the “gate” has an applied voltage to it (effectively “lowering the barrier” for electrons to get through). This theory was sound and based on the recently developed quantum electron theory of metals developed by Wolfgang Pauli, Werner Heisenberg, Arnold Sommerfeld, Felix Bloch, and Rudolf Peierls  [7]. And indeed, the people at Bell labs worked on this problem theoretically and experimentally for the beginning in the 1930s (for a full history, see  [7]). Despite the strong foundations though, creating a field effect transistor turned out to be difficult, and in the process Brattain and Bardeen instead created the point-contact transistor.\n\n\n1.2.2 The Point Contact Transistor\n\n\n\n\n\n\n\n\n\n\n\n(a) Schematic of the point contact transistor3.\n\n\n\n\n\n\n\n\n\n\n\n(b) Replica of first transistor\n\n\n\n\n\n\n\nFig. 1.3: The point contact transistor.\n\n\n\nThe point-contact transistor, invented in 1947, worked quite differently from the field-effect design. Instead of using a voltage at a gate to control current flow, it used two very closely spaced metal contacts pressed against a semiconductor (typically germanium). One contact, called the emitter, would inject positive charge carriers (holes) into the semiconductor. The second contact, called the collector, would collect these carriers - but crucially, the amount of current that could flow through the collector could be controlled by small changes in the emitter current4. A schematic and image of a replica of the original device are illustrated in Fig. 1.3.\nThis amplification effect, where a small current controls a larger one, was revolutionary–though the exact physics behind it wasn’t fully understood at the time. The key was that the metal contacts created special regions in the semiconductor where the positive carriers modified the barrier for current flow from the bulk material. While the detailed quantum mechanics is complex, you can think of it like creating “paths” that electrons prefer to take through the material, with the emitter current controlling how easily electrons can flow along these paths to the collector.\nWhile point-contact transistors were eventually superseded by more reliable and easier-to-manufacture designs, they represented a crucial breakthrough in electronics. They proved that solid-state devices could indeed amplify electrical signals. However, they were quite large. The original design for a field effect transistor would be needed, and they key resided in understanding and control the surface physics of semiconductors.\n\n\n1.2.3 Surface physics and transistors\nThe key challenge in creating field effect transistors lay in understanding and controlling the surface properties of semiconductors. To understand why this was so difficult, let’s break it down:\nWhen a semiconductor crystal (like silicon) ends at a surface, something interesting happens. The regular pattern of atoms is suddenly interrupted - imagine a neat stack of blocks suddenly ending in mid-air. This interruption creates what we call “surface states” - special energy levels that electrons can occupy right at the surface of the material.\nThese surface states turned out to be extremely problematic for making transistors. Remember that in a field effect transistor, we want to control the flow of electrons using an electric field from the gate (see Fig. 1.2). However, these surface states acted like tiny electron traps, capturing and holding onto electrons. When electrons got stuck in these states, they effectively “screened” or blocked the electric field from the gate, preventing it from controlling the current flow through the semiconductor.\nThis screening effect was so strong that early attempts at field effect transistors simply didn’t work–no matter how strong a voltage was applied to the gate, it couldn’t effectively control the current flow. It was like trying to control a water flow with a valve, but having something constantly blocking the valve from moving.\nThe breakthrough came in the 1950s when researchers, particularly at Bell Labs, realized they needed to chemically “passivate” the semiconductor surface–essentially finding ways to neutralize these problematic surface states. The key discovery was that growing a thin layer of silicon dioxide (SiO₂) on silicon created a much more stable interface with far fewer problematic surface states. This oxide layer also served as an excellent insulator between the gate and the semiconductor.\nThis seemingly simple solution–growing an oxide layer–was actually a remarkable achievement that required precise control of material chemistry and manufacturing processes. It finally allowed the creation of practical field effect transistors, leading to the modern MOSFET (Metal-Oxide-Semiconductor Field Effect Transistor) that forms the backbone of today’s electronics.\nThe success of this approach also highlights an important lesson in technology development: sometimes the biggest breakthroughs come not from changing the fundamental design, but from finding ways to control and manage the subtle physical effects that prevent a good design from working in practice.\n\n\n1.2.4 Where are we with quantum computing?\nImagine that this course existed back in the 1950s and we called it “Computing Technology.” Transistors were still coming online to enable computation at scale and we had both the information science and material theory to achieve it:\n\nWe knew what was needed to do universal classical computation.\nWe had the quantum theory of metals to describe how to build components (transistors) to achieve classical computation.\n\nHowever, the engineering challenges took decades to resolve. It was only when we resolved those that computation as we currently envision it took off and we could have classical computers.\nFor quantum computing, we are in a similar situation:\n\nWe know what is needed to do universal quantum computation.\nWe have the quantum theory of photons, atoms, and superconductivity to achieve quantum computation.\n\nHowever, as we will see in what follows, we have significant engineering challenges to achieve these in practice. While we will be largely concerned with the physics that make #2 possible in this course (and we’ll touch on #1 for the first part of the course), we will pay attention to the strengths and weaknesses in the physics that lead to more pressing engineering challenges.\n\n\n\n\n\n\nHistorical Parallel\n\n\n\nJust as the theory of classical computation  [6] preceded practical computers by decades, we now have the theory of quantum computation  [5] but face significant engineering challenges. The key difference is that we’re trying to control individual quantum systems rather than classical electrical currents.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#review-of-the-postulates-of-quantum-mechanics",
    "href": "intro.html#review-of-the-postulates-of-quantum-mechanics",
    "title": "1  Introduction",
    "section": "1.3 Review of the Postulates of Quantum Mechanics",
    "text": "1.3 Review of the Postulates of Quantum Mechanics\nQuantum mechanics is built out of some basic postulates which are crucial to understand for quantum computation. When we talk about a “system” in these postulates, we will be thinking of two-level systems which we can label 0 or 1 (for our qubit). However, we will state them generally since many applications require some basic work to reduce the complicated system down to just the qubits we are interested in.\n\n\n\n\n\n\nMathematical Notation Guide\n\n\n\nThroughout this text, we’ll use:\n\n\\(\\ket{\\psi}\\) (“ket psi”): Represents a quantum state\n\\(\\bra{\\phi}\\) (“bra phi”): The dual vector to \\(\\ket{\\phi}\\)\n\\(\\braket{\\phi|\\psi}\\): The inner product between states\n\\(\\otimes\\): The tensor product operation\n\nThese notations provide a compact way to describe quantum systems.\n\n\n\n1.3.1 Postulate I: The Hilbert space\n\nA state in an isolated physical system \\(S\\) can be described by a set of normalized state vectors–\\(\\ket{\\psi}\\) and all vectors related by a phase \\(\\ket{\\psi'} = e^{i\\phi}\\ket{\\psi}\\)–belonging in the Hilbert space \\(\\mathcal H_S\\).\n\nimportantly, a Hilbert space is equipped with an inner product (much like the dot product in three-dimensions) \\(\\braket{\\alpha | \\beta}\\).\nWe also need rules for attaching Hilbert spaces to one another. Afterall, we will need to use more than one qubit to do anything interesting.\n\nThe Hilbert space of a composite system is the tensor product of the two individual systems \\(\\mathcal H_{AB} = \\mathcal H_A \\otimes \\mathcal H_B\\).\n\n\n\n1.3.2 Postulate II: Physical Observables and Measurements\nThis postulate is also sometimes called the Born rule.\nIn order to measure the system (e.g., “where is the particle?” or “Is the qubit a 0 or 1?”), we need to know what physical observables are\n\n\nEvery physical observable \\(a\\) can be described as a Hermitian operator \\(A\\) acting in the Hilbert Space.\n\n\nFormally, a Hermitian operator has \\(A = A^\\dagger\\) where \\(A^\\dagger\\) is the conjugate transpose of \\(A\\). These operators have a whole set of orthonormal eigenstates \\(A\\ket{a_n} = a_n\\ket{a_n}\\) for a real number \\(a_n\\) (orthonormal means \\(\\braket{a_n| a_m} = \\delta_{nm}\\)). These mathematical details are important for how we will perform measurements\n\n\nWhen a physical observable with operator \\(A\\) is measured on a normalized eigenstate \\(\\ket{\\psi}\\), the result is an eigenvalue \\(a_n\\) of that operator with probability \\(p_n = \\lvert \\braket{a_n |\\psi} \\rvert^2\\) (or in the case of a degeneracy \\(d\\), \\(p_n = \\sum_{i=1}^d \\lvert \\braket{a_n, i | \\psi}\\vert^2\\)).\n\n\nIf we measure \\(A\\) repeatedly, we are naturally lead to the expectation value \\(\\braket{\\psi | A |\\psi} = a = \\sum_n a_n p_n\\), the average result of repeated quantum mechanical measurements. Once a measurement is performed, however, the state is changed, for this we need an operator \\(P_n\\) which projects onto the eigenspace of \\(A\\) associated with the eigenvalue \\(a_n\\).\n\n\nWhen a measurement of the observable \\(A\\) gives a results \\(a_n\\), the state is changed to be the normalized projection of \\(\\ket{\\psi}\\) to the eigenspace associated with \\(a_n\\) \\[ \\ket{\\psi} \\quad \\implies \\quad \\frac{P_n \\ket{\\psi}}{\\sqrt{\\braket{\\psi|P_n | \\psi}}} \\]\n\n\nIf the eigenstates are not degenerate, then \\(\\ket{\\psi} \\implies \\ket{a_n}\\). However, we will find that we will often have degenerate states, and in that case \\[\n\\ket{\\psi} \\implies \\frac{\\sum_{i=1}^d \\braket{a_n, i | \\psi} \\ket{a_n, i}}{\\sqrt{\\sum_{i=1}^d \\lvert \\braket{a_n,i | \\psi}\\rvert^2}}.\n\\] One comfortable with the braket notation might notice that within this, \\(P_n = \\sum_{i=1}^d \\ket{a_n,i}\\bra{a_n,i}\\).\n\n\n1.3.3 Postulate III: Time-evolution of a system\nWhile we will talk about Hamiltonians, often in quantum computation we have gates that do not require these. In this case, we state this postulate as abstractly as possible\n\nThe time evolution of a closed system from some time \\(t_0\\) and state \\(\\ket{\\psi_0}\\) to a final time \\(t\\) and state \\(\\ket{\\psi}\\) can be described as a unitary transformation \\[ \\ket{\\psi} = U(t,t_0) \\ket{\\psi_0}.\\]\n\nThis postulate is necessary for us to maintain probabilities. Unitary operators have the property that \\(UU^\\dagger = U^\\dagger U = \\mathbb{1}\\), and so \\[1 = \\braket{\\psi_0|\\psi_0} = \\braket{\\psi_0|U^\\dagger U| \\psi_0} = \\braket{\\psi|\\psi}.\\]\nIn the case of time-independent Hamiltonian dynamics, the operator takes the form \\(U = e^{-i H t/\\hbar}\\) for a hermitian energy operator \\(H\\) called the Hamiltonian.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#a-brief-history-of-computing-from-classical-to-quantum",
    "href": "intro.html#a-brief-history-of-computing-from-classical-to-quantum",
    "title": "1  Introduction",
    "section": "1.4 A Brief History of Computing: From Classical to Quantum",
    "text": "1.4 A Brief History of Computing: From Classical to Quantum\nThe concept that information is physical underlies both classical and quantum computation. Even in the earliest systems of record-keeping, we see physical objects encoding information:\n\nKish Tablet (3500 BCE): A limestone tablet from Kish showing a record of pictographic writing.\nQuipu (2600–1900 BCE): A system of knotted ropes used by the Inca civilization for keeping records. The color, order, and number of knots all represented quantifiable or categorical data.\n\nThese examples highlight that from the very beginning, the act of storing and manipulating information has always had a physical basis—though the underlying physics often remained implicit for centuries.\n\n1.4.1 Classical Computing Foundations\nThe paradigm of classical computing rests on a few fundamental ideas:\n\nBoolean Logic & Universal Gates: All classical computers can be built from a finite set of universal logical gates (e.g., {NAND}, {NOR}, or {AND, NOT}).\n\nMost Boolean operations (AND, OR, NAND, etc.) are inherently irreversible: once a bit is erased or overwritten, the original state cannot be recovered from the output alone.\n\nExtended (Physical) Church–Turing Thesis: A probabilistic Turing machine can efficiently simulate any realistic physical model of computation with at most polynomial overhead.\n\nThis thesis, while unproven, underpins the expectation that classical computers (or at least classical models) are sufficient for simulating any physical system in principle. Quantum computation potentially challenges this with a polynomial in time algorithm (Shor’s algorithm) that is exponential in time classically.\n\n\n1.4.2 The Emergence of Quantum Information\nWhile classical computing relies on bits that are strictly 0 or 1, quantum computing introduces powerful new concepts:\n\nSuperposition: A quantum bit (qubit) can be in a linear combination of basis states (e.g., simultaneously “0” and “1” with certain complex amplitudes).\nEntanglement: Two or more qubits can become correlated in such a way that measuring one affects the outcomes for the others, even across vast distances.\n\nThe key question that launched the field of quantum information was whether these uniquely quantum properties—superposition and entanglement—could be exploited to perform computations more efficiently than any classical device.\nIn his seminal work, Simulating Physics with Computers  [8], Richard Feynman observed that simulating quantum many-body systems on classical computers seems to require exponential resources. He posed the idea of harnessing genuine quantum systems themselves for simulation, planting the seeds for quantum computation as a research field.\nThen, in a series of groundbreaking results between the 1980s and 1990s, researchers demonstrated that quantum computers could, in principle, outperform classical computers for certain tasks:\n\nDeutsch (1985)  [9]: Showed that it is possible to carry out a simple computational task on a quantum computer faster than any classical algorithm.\nDeutsch–Jozsa (1992)  [10]: Introduced a deterministic quantum algorithm that is exponentially faster (in the worst case) than any deterministic classical algorithm.\nBernstein–Vazirani (1992)  [11]: Demonstrated a probabilistic quantum algorithm faster than any probabilistic classical algorithm.\nSimon (1994)  [12]: Provided a probabilistic quantum algorithm that is exponentially faster than any probabilistic classical algorithm for a specific promise problem.\nShor (1994)  [13]: Showed how to factor integers efficiently, providing an exponential speedup over the best known classical methods. This result was particularly striking for cryptography, as factoring large numbers underpins many encryption schemes.\n\nAlongside these algorithmic milestones, researchers began to delineate the limitations: not every problem can be exponentially sped up by quantum methods. For instance, Grover’s algorithm (1996)  [14] for unstructured search yields a quadratic speedup (from \\(N\\) to \\(\\sqrt{N}\\))—still better than classical, but not the exponential leap that Shor’s algorithm provides for factoring.\n\n\n1.4.3 Analog vs. Digital Quantum Simulation\nAs the field grew, quantum simulation branched into two approaches:\n\nAnalog Quantum Simulation: Uses a controllable quantum system to mimic a target quantum system. The interactions in the simulator closely resemble the interactions in the system of interest.\nDigital Quantum Simulation: Decomposes a quantum evolution into a sequence of discrete gates (a “universal” set of quantum gates), akin to how classical digital computers function using logical gate operations.\n\nBoth approaches aim to exploit quantum mechanics to tackle problems in mathematics, physics, chemistry, and materials science that remain intractable for classical supercomputers.\nAmid ongoing research, the interplay between classical and quantum paradigms remains a vibrant area of exploration. While classical computing infrastructure continues to be indispensable, quantum computing offers the promise of qualitatively new capabilities—provided we can tame the noise, errors, and fragilities inherent to quantum states.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#quantum-technologies",
    "href": "intro.html#quantum-technologies",
    "title": "1  Introduction",
    "section": "1.5 Quantum Technologies",
    "text": "1.5 Quantum Technologies\nOne major difference between the hindsight-history we have for classical computation and the current state of quantum computers is that are many platforms vying to enable quantum computation. There are arguments for and against each platform, and even arguments for using a combination of platforms. Here we give a list of some of the technologies and highlight the ones we will be surveying in this course.\nPlatforms covered in this course\n\nSuperconducting qubits: Artificial atoms made from superconducting circuits that operate at ultra-low temperatures. Currently the most mature platform, used by companies like IBM and Google.\nTrapped ions: Individual atoms held in place by electromagnetic fields. Known for having very long coherence times and high-fidelity gates. Major players include IonQ and Quantinuum (formerly of Honeywell).\nPhotonic quantum computers: Use particles of light (photons) as qubits. Can operate at room temperature and naturally interface with quantum communication systems. Being developed by companies like PsiQuantum and Xanadu.\n\nOther platforms we will not cover\n\nSilicon quantum dots: Quantum bits made from individual electrons trapped in silicon, similar to classical semiconductor technology. Could potentially leverage existing manufacturing processes.\nNeutral atoms and Rydberg arrays: Individual neutral atoms arranged in arrays using laser beams. When excited to high-energy Rydberg states, atoms can interact strongly with their neighbors. Can create large numbers of identical qubits with programmable interactions. Companies like QuEra are pursuing this approach.\nNV centers: Quantum bits made from nitrogen-vacancy defects in diamond. Can operate at room temperature and have long coherence times, making them particularly promising for quantum sensing and networking applications.\n\nA platform we will cover if time permits\n\nTopological qubits: A theoretical approach that would use special quantum states of matter to create error-protected qubits. Still in early research stages but could offer significant advantages if realized.\n\n\n\n\n\n\n\nCurrent State of Quantum Computing\n\n\n\nAs of 2024, the largest quantum computers have around 50-100 physical qubits optimistically, but these are noisy and require error correction. For comparison, your smartphone has billions of classical bits. This highlights the early stage of quantum computing development and the engineering challenges ahead.\n\n\nEach platform has its own advantages and challenges in terms of scalability, error rates, coherence times, and manufacturing complexity. The field is still evolving, and it’s possible that different platforms may be optimal for different applications.\n\n\n\n\n[1] F. Arute et al., Quantum supremacy using a programmable superconducting processor, Nature 574, 505 (2019).\n\n\n[2] Google Quantum AI and Collaborators et al., Quantum error correction below the surface code threshold, Nature (2024).\n\n\n[3] E. Pednault, J. A. Gunnels, G. Nannicini, L. Horesh, and R. Wisnieff, Leveraging Secondary Storage to Simulate Deep 54-qubit Sycamore Circuits, arXiv:1910.09534 (2019).\n\n\n[4] F. Pan, K. Chen, and P. Zhang, Solving the Sampling Problem of the Sycamore Quantum Circuits, Physical Review Letters 129, 090502 (2022).\n\n\n[5] M. A. Nielsen and I. L. Chuang, Quantum Computation and Quantum Information: 10th Anniversary Edition, Anniversary edition (Cambridge University Press, Cambridge ; New York, 2011).\n\n\n[6] A. M. Turing, On Computable Numbers, with an Application to the Entscheidungsproblem, Proceedings of the London Mathematical Society s2-42, 230 (1937).\n\n\n[7] L. Hoddeson, The Discovery of the Point-Contact Transistor, Historical Studies in the Physical Sciences 12, 41 (1981).\n\n\n[8] R. P. Feynman, Simulating physics with computers, International Journal of Theoretical Physics 21, 467 (1982).\n\n\n[9] D. Deutsch, Quantum theory, the Church–Turing principle and the universal quantum computer, Proceedings of the Royal Society of London. A. Mathematical and Physical Sciences 400, 97 (1985).\n\n\n[10] D. Deutsch and R. Jozsa, Rapid solution of problems by quantum computation, Proceedings of the Royal Society of London. Series A: Mathematical and Physical Sciences 439, 553 (1992).\n\n\n[11] E. Bernstein and U. Vazirani, Quantum Complexity Theory, SIAM Journal on Computing 26, 1411 (1997).\n\n\n[12] D. R. Simon, On the Power of Quantum Computation, SIAM Journal on Computing 26, 1474 (1997).\n\n\n[13] P. W. Shor, Algorithms for Quantum Computation: Discrete Logarithms and Factoring, in Proceedings 35th Annual Symposium on Foundations of Computer Science (IEEE Comput. Soc. Press, Santa Fe, NM, USA, 1994), pp. 124–134.\n\n\n[14] L. K. Grover, A Fast Quantum Mechanical Algorithm for Database Search, in Proceedings of the Twenty-Eighth Annual ACM Symposium on Theory of Computing - STOC ’96 (ACM Press, Philadelphia, Pennsylvania, United States, 1996), pp. 212–219.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "intro.html#footnotes",
    "href": "intro.html#footnotes",
    "title": "1  Introduction",
    "section": "",
    "text": "Note that P or N stands for positive or negative carriers.↩︎\nMade by VectorVoyager and licensed under Creative Commons Attribution-Share Alike 3.0 Unported↩︎\nLicensed under Creative Commons CC0 1.0 Universal Public Domain Dedication.↩︎\nFor details on how this was made, see How the first transistor worked↩︎",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "qubit.html",
    "href": "qubit.html",
    "title": "2  The Qubit",
    "section": "",
    "text": "2.1 The Qubit Hilbert space\nThe fundamental building block of the classical computer was the bit: A 0 or 1 that could be manipulated by a classical computer (via transistors, see Section 1.2). In a similar manner, quantum computation has the “quantum bit” or just qubit, for short. This leads us to the linear algebra of \\(2\\times 2\\) matrices, as we will see. Despite the apparent simplicity, we can already see many of the key features of quantum mechanics in this simple system.\nA qubit will be in two-dimensional complex vector space equipped with an inner product.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>The Qubit</span>"
    ]
  },
  {
    "objectID": "qubit.html#the-qubit-hilbert-space",
    "href": "qubit.html#the-qubit-hilbert-space",
    "title": "2  The Qubit",
    "section": "",
    "text": "2.1.1 Qubit states\nFor the qubit, we associate two states with two different basis vectors: \\(\\ket{0}\\) and \\(\\ket{1}\\). This will be called the computational basis. The magic1 of quantum mechanics is that a state need not be just one or the other, but could be any linear superposition of these \\[\n\\ket{\\psi} = \\alpha \\ket{0} + \\beta \\ket{1}.\n\\tag{2.1}\\] In this, we have adopted the bra-ket notation due to Dirac. While it can be quite useful, we can write this in terms of matrices and vectors \\[\n\\ket{0} = \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix}, \\quad \\ket{1} = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix}.\n\\] This makes it clear that these states are orthogonal \\(\\braket{0|1} = 0\\).\nIn this case we have \\[\n\\ket{\\psi} = \\begin{bmatrix} \\alpha \\\\ \\beta \\end{bmatrix}.\n\\] We also need the conjugate transpose, the Hermitian conjugate, of this vector, which will be a row-vector \\[\n\\bra{\\psi} = \\begin{bmatrix} \\alpha^* & \\beta^* \\end{bmatrix}.\n\\] The key feature of quantum mechanics is that these states must be normalized, meaning that the probability of finding the system in any state must sum to 1. This means that \\[\n\\braket{\\psi|\\psi} = \\begin{bmatrix} \\alpha^* & \\beta^* \\end{bmatrix} \\begin{bmatrix} \\alpha \\\\ \\beta \\end{bmatrix} = |\\alpha|^2 + |\\beta|^2 = 1.\n\\] In matrix notation, this is just the dot product of a vector with its complex conjugate.\n\n\n\n\n\n\nWhy Normalization Matters\n\n\n\nThe normalization condition \\(|\\alpha|^2 + |\\beta|^2 = 1\\) isn’t just mathematical convenience - it ensures probabilities add up to 100%! For example:\n\n\\(\\ket{\\psi} = \\frac{1}{\\sqrt{2}}(\\ket{0} + \\ket{1})\\) gives 50-50 chance of measuring 0 or 1\n\\(\\ket{\\psi} = \\frac{\\sqrt{3}}{2}\\ket{0} + \\frac{1}{2}\\ket{1}\\) gives 75% chance of 0 and 25% chance of 1\n\n\n\nWe can also write operators that act on these states. The simplest operator is the Pauli \\(Z\\) operator, which in matrix form is \\[\nZ = \\begin{bmatrix} 1 & 0 \\\\ 0 & -1 \\end{bmatrix}.\n\\] When this operator acts on our basis states, we find \\[\nZ\\ket{0} = \\ket{0}, \\quad Z\\ket{1} = -\\ket{1}.\n\\] This means that \\(\\ket{0}\\) and \\(\\ket{1}\\) are eigenstates of \\(Z\\) with eigenvalues \\(+1\\) and \\(-1\\) respectively. For a general state \\(\\ket{\\psi}\\), measuring \\(Z\\) will yield either \\(+1\\) or \\(-1\\), with probabilities determined by \\(|\\alpha|^2\\) and \\(|\\beta|^2\\) respectively.\n\n\n\n\n\n\nExample: Measuring a superposition state\n\n\n\nConsider the state \\(\\ket{\\psi} = \\frac35\\ket{0} + \\frac45\\ket{1}\\). When we measure this state in the \\(Z\\) basis:\nNotice that this state is normalized since \\((\\frac{3}{5})^2 + (\\frac{4}{5})^2 = 1\\). If we measure this state in the computational basis:\n\nWe’ll get outcome \\(\\ket{0}\\) with probability \\(|\\frac{3}{5}|^2 = 0.36\\) (36%)\nWe’ll get outcome \\(\\ket{1}\\) with probability \\(|\\frac{4}{5}|^2 = 0.64\\) (64%)\n\nAfter measurement, the state will collapse to either \\(\\ket{0}\\) or \\(\\ket{1}\\) with the above probabilities\n\n\n\n\n\n\n\n\nMeasurement Collapse in Practice\n\n\n\nWhen we say a quantum state “collapses” upon measurement, what actually happens in the lab?\n\nFor a superconducting qubit: We measure a voltage or current\nFor an ion trap: We detect scattered photons\nFor a photonic qubit: We count photons with a detector\n\nEach technology has its own way of converting quantum information into classical signals!\n\n\n\n\n2.1.2 Qubit operators\nSince this is linear algebra, we can write a general operator \\(\\mathcal O\\) as a matrix \\[\n\\mathcal O = \\begin{bmatrix} a & b \\\\ c & d \\end{bmatrix}.\n\\] Often, we are interested in the eigenvalues and eigenstates of these operators \\(\\mathcal O \\ket{\\psi_{i}} = \\lambda_i \\ket{\\psi_i}\\). Generically, we can find these by solving a polynomial equation \\[\n\\det(\\mathcal O - \\lambda I) = 0.\n\\]\nSolving this step-by-step \\[\n\\det(\\mathcal O - \\lambda I) = \\begin{vmatrix} a-\\lambda & b \\\\ c & d-\\lambda \\end{vmatrix} = 0,\n\\] which gives us \\[\n(a-\\lambda)(d-\\lambda) - bc = 0.\n\\] This is a quadratic equation that we can solve: \\[\n\\lambda^2 - (a+d)\\lambda + (ad-bc) = 0.\n\\]\nThe eigenvalues are therefore \\[\n\\lambda_{\\pm} = \\frac{a+d \\pm \\sqrt{(a-d)^2 + 4bc}}{2}.\n\\tag{2.2}\\]\nFor quantum mechanical observables (see Section 1.3.2), we are particularly interested in Hermitian operators where \\(\\mathcal O = \\mathcal O^\\dagger\\), \\[\n\\begin{bmatrix} a & b \\\\ c & d \\end{bmatrix} = \\begin{bmatrix} a^* & c^* \\\\ b^* & d^* \\end{bmatrix}\n\\] This means that \\(a\\) and \\(d\\) must be real and \\(c = b^*\\). In this case, the eigenvalues are always real, as we can see from the Eq. 2.2.\nA particularly important class of operators are unitary operators, where \\(U^\\dagger U = UU^\\dagger = I\\). These are what we use for time-evolution, see Section 1.3.3.\nThese operators preserve the inner product between states: \\[\n\\braket{U\\psi|U\\phi} = \\braket{\\psi|\\phi}\n\\] For a \\(2\\times 2\\) matrix \\[\nU = \\begin{bmatrix} a & b \\\\ c & d \\end{bmatrix},\n\\] the unitarity condition means that \\[\n\\begin{bmatrix} a^* & c^* \\\\ b^* & d^* \\end{bmatrix} \\begin{bmatrix} a & b \\\\ c & d \\end{bmatrix} = \\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix}.\n\\]\nThis gives us several conditions:\n\n\\(|a|^2 + |c|^2 = 1\\) (normalization of first column)\n\\(|b|^2 + |d|^2 = 1\\) (normalization of second column)\n\\(ab^* + cd^* = 0\\) (orthogonality of columns)\n\nThis immediately gives us some insight into these operators. If we define, \\[\n\\ket{\\psi_1} = \\begin{bmatrix} a \\\\ c \\end{bmatrix}, \\quad \\ket{\\psi_2} = \\begin{bmatrix} b \\\\ d \\end{bmatrix},\n\\] then we have \\(\\braket{\\psi_1|\\psi_1} = 1 = \\braket{\\psi_2|\\psi_2}\\) and \\(\\braket{\\psi_1|\\psi_2} = 0\\).\nAn important property of unitary operators is that their eigenvalues always have magnitude 1, meaning they can be written as \\(e^{i\\theta}\\) for some real \\(\\theta\\). This makes them natural operators for describing quantum evolution.\n\n\n\n\n\n\nWhy Unitary?\n\n\n\nUnitary operators are special because they:\n\nPreserve the normalization of quantum states\nAre reversible (have an inverse)\nRepresent physical operations that conserve probability\n\nThis is why quantum gates must be unitary - they represent real physical processes that can be undone!\n\n\n\n\n2.1.3 The Pauli operators\nA particularly important set of operators are the Pauli operators. We’ve already seen the Pauli \\(Z\\) operator. The other two are2 \\[\nX = \\begin{bmatrix} 0 & 1 \\\\ 1 & 0 \\end{bmatrix}, \\quad Y = \\begin{bmatrix} 0 & -i \\\\ i & 0 \\end{bmatrix}.\n\\] These operators satisfy some important algebraic relations: \\[\nX^2 = Y^2 = Z^2 = I, \\quad XY = iZ, \\quad YZ = iX, \\quad ZX = iY.\n\\] We can additionally start to see some logical operations begin to appear; \\(X\\) operates on the computational basis as a NOT gate \\[\nX \\ket{0} = \\ket{1}, \\quad X \\ket{1} = \\ket{0}.\n\\]\n\n\n\n\n\n\nPauli Operators in Action\n\n\n\nThe Pauli operators represent quantum operations:\n\n\\(X\\) is like the classical NOT gate: flips between \\(\\ket{0}\\) and \\(\\ket{1}\\)\n\\(Z\\) adds a phase: leaves \\(\\ket{0}\\) alone but negates \\(\\ket{1}\\)\n\\(Y = iXZ\\) combines both operations.\n\nThese simple operations are building blocks for more complex quantum algorithms!\n\n\n\n\n\n\n\n\nExample: Applying operators\n\n\n\nLet’s apply the X (NOT) gate to our state \\(\\ket{\\psi} = (\\tfrac{3}{5}\\ket{0} + \\tfrac{4}{5}\\ket{1})\\): \\[\n\\begin{aligned}\nX\\ket{\\psi} &= X(\\tfrac{3}{5}\\ket{0} + \\tfrac{4}{5}\\ket{1}) \\\\\n&= \\tfrac{3}{5}X\\ket{0} + \\tfrac{4}{5}X\\ket{1} \\\\\n&= \\tfrac{3}{5}\\ket{1} + \\tfrac{4}{5}\\ket{0} \\\\\n&= \\tfrac{4}{5}\\ket{0} + \\tfrac{3}{5}\\ket{1}\n\\end{aligned}\n\\]\n\n\nThe full set of Pauli operators, along with the identity, form a complete basis for \\(2\\times 2\\) matrices, meaning we can write any operator as \\[\n\\mathcal O = aI + bX + cY + dZ,\n\\] where \\(a\\), \\(b\\), \\(c\\), and \\(d\\) are complex numbers. We can extract each of these numbers, mathematically, with a trace operation \\[\n\\tr \\mathcal O = 2a, \\quad \\tr \\mathcal O X = 2b, \\quad \\tr \\mathcal O Y = 2c, \\quad \\tr \\mathcal O Z = 2d.\n\\] Note that separately, \\(X\\), \\(Y\\), and \\(Z\\) are Hermitian (and thus, observables). If \\(\\mathcal O\\) is an observable, then \\(\\mathcal O = \\mathcal O^\\dagger\\) immediately leads us to \\(a\\), \\(b\\), \\(c\\), and \\(d\\) being all real.\nWe can put constraints on these coefficients for unitary operators as well, and we leave this as an exercise for the reader.\nFinally, these operators have eigenstates as well, and we can define them as \\(X\\ket{\\pm} = \\pm \\ket{\\pm}\\) and \\(Y\\ket{\\pm i} = \\pm \\ket{\\pm i}\\), and they have the forms \\[\n\\begin{aligned}\n    \\ket{\\pm} & = \\tfrac1{\\sqrt2}(\\ket 0 \\pm \\ket 1), \\\\\n    \\ket{\\pm i} & = \\tfrac1{\\sqrt2}(\\ket 0 \\pm i \\ket 1).\n\\end{aligned}\n\\]\nWe will often want to change our basis from \\(\\ket{0}\\) and \\(\\ket{1}\\) to \\(\\ket{+}\\) and \\(\\ket{-}\\). This is accomplished with something called the Hadamard gate (we’ll call it \\(H\\), not to be confused with a Hamiltonian) and it is created specifically to change from computational basis to the \\(X\\) basis: \\(H \\ket{0} = \\ket{+}\\) and \\(H \\ket{1} = \\ket{-}\\). As a matrix it takes the form \\[\nH = \\frac1{\\sqrt{2}}\\begin{bmatrix} 1 & 1 \\\\ 1 & -1 \\end{bmatrix}.\n\\]\n\n\n\n\n\n\nThe Power of Hadamard\n\n\n\nThe Hadamard gate is one of the most important gates in quantum computing with useful properties:\n\nIt creates equal superpositions from computational basis states.\nIt’s its own inverse (\\(H^2 = I\\))\nIt’s used in nearly every quantum algorithm\nWhen applied to \\(n\\) qubits, it creates a superposition of all \\(2^n\\) possible bit strings!\n\n\n\n\n\n\n\n\n\nExample 3: The Hadamard Transform\n\n\n\nThe Hadamard gate is particularly important because it creates superposition states. Let’s see what happens when we apply it to \\(\\ket{0}\\): \\[\n\\begin{aligned}\nH\\ket{0} &= \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 & 1 \\\\ 1 & -1 \\end{bmatrix}\\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} \\\\\n&= \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 \\\\ 1 \\end{bmatrix} \\\\\n&= \\frac{1}{\\sqrt{2}}(\\ket{0} + \\ket{1}) \\\\\n&= \\ket{+}\n\\end{aligned}\n\\]",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>The Qubit</span>"
    ]
  },
  {
    "objectID": "qubit.html#sec-bloch-sphere",
    "href": "qubit.html#sec-bloch-sphere",
    "title": "2  The Qubit",
    "section": "2.2 The Bloch sphere",
    "text": "2.2 The Bloch sphere\nThe qubit itself is more than just a probability of being a 1 or a 0. A crucial bit of quantum information is the relative phase between the two states for instance \\[\n\\ket{\\psi} = \\tfrac1{\\sqrt2}( \\ket 0 + e^{i\\phi} \\ket 1),\n\\] and since all states are equivalent up to a total phase, we can write the amplitude of each state with a real number. In this case, if we set \\(\\ket{\\psi} = x \\ket{0} + y e^{i\\phi} \\ket 1\\), then we have \\(\\braket{\\psi|\\psi} = x^2 + y^2 = 1\\) for normalization. This is the equation for a circle, and writing out \\(x = \\cos(\\theta/2)\\) and \\(y = \\sin(\\theta/2)\\)3, we are lead to an angular representation of our state. \\[\n\\ket{\\psi} = \\cos(\\theta/2) \\ket{0} + \\sin(\\theta/2)e^{i\\phi} \\ket{1}.\n\\tag{2.3}\\] Let’s see how this state relates to our Pauli operators. If we calculate the expectation values of each operator:\n\\[\n\\begin{aligned}\n\\langle X \\rangle &= \\bra{\\psi}X\\ket{\\psi} \\\\\n&= (\\cos(\\theta/2) \\bra{0} + \\sin(\\theta/2)e^{-i\\phi} \\bra{1})\n   X\n   (\\cos(\\theta/2) \\ket{0} + \\sin(\\theta/2)e^{i\\phi} \\ket{1}) \\\\\n&= (\\cos(\\theta/2) \\bra{0} + \\sin(\\theta/2)e^{-i\\phi} \\bra{1})\n   (\\cos(\\theta/2) \\ket{1} + \\sin(\\theta/2)e^{i\\phi} \\ket{0}) \\\\\n&= \\sin(\\theta/2)\\cos(\\theta/2) e^{i\\phi} + \\cos(\\theta/2)\\sin(\\theta/2)e^{-i\\phi} \\\\\n&= \\sin(\\theta/2)\\cos(\\theta/2) (e^{i\\phi} + e^{-i\\phi}) \\\\\n&= 2\\sin(\\theta/2)\\cos(\\theta/2) \\cos\\phi \\\\\n&= \\sin \\theta \\cos\\phi.\n\\end{aligned}\n\\] We can carry out a similar calculation for \\(Y\\) and \\(Z\\) to obtain \\[\n\\begin{aligned}\n\\langle X \\rangle &= \\bra{\\psi}X\\ket{\\psi} = \\sin\\theta\\cos\\phi \\\\\n\\langle Y \\rangle &= \\bra{\\psi}Y\\ket{\\psi} = \\sin\\theta\\sin\\phi \\\\\n\\langle Z \\rangle &= \\bra{\\psi}Z\\ket{\\psi} = \\cos\\theta\n\\end{aligned}\n\\]\nThese expectation values give us coordinates , which are precisely the coordinates of a point on a unit sphere! This is why we call it the Bloch sphere. The angles \\(\\theta\\) and \\(\\phi\\) are the usual spherical coordinates.\n\n\n\n\n\n\nThe Bloch Sphere Geometry\n\n\n\n\nThe north pole (\\(\\theta=0\\)) corresponds to \\(\\ket{0}\\)\nThe south pole (\\(\\theta=\\pi\\)) corresponds to \\(\\ket{1}\\)\nThe equator (\\(\\theta=\\pi/2\\)) contains equal superposition of computational basis states:\n\n\\(\\phi=0\\) gives \\(\\ket{+}\\) (positive x-axis)\n\\(\\phi=\\pi\\) gives \\(\\ket{-}\\) (negative x-axis)\n\\(\\phi=\\pi/2\\) gives \\(\\ket{+i}\\) (positive y-axis)\n\\(\\phi=3\\pi/2\\) gives \\(\\ket{-i}\\) (negative y-axis)\n\n\n\n\n\n\n\n\n\n\n\nFig. 2.1: The Bloch sphere showing eigenstates of X, Y, and Z Pauli operators\n\n\n\n\n\n\n\n\n\nExample: Hadamard Gate on \\(\\ket{0}\\)\n\n\n\nThe Hadamard gate \\(H\\) takes the state \\(\\ket{0}\\) (north pole) to \\(\\ket{+}\\) (on the equator at \\(\\phi=0\\)). In terms of the Bloch sphere coordinates, this means:\n\nStarting point: \\(\\theta=0\\) (north pole)\nEnding point: \\(\\theta=\\pi/2\\), \\(\\phi=0\\) (positive x-axis)\n\nThe gate effectively rotates the state by 90° around the y-axis. Similarly, \\(H\\ket{1}\\) takes the south pole to \\(\\ket{-}\\) on the negative x-axis.\n\n\n\n2.2.1 General Unitary Rotations\nThe Hadamard example shows how unitary gates can rotate states on the Bloch sphere. More generally, any single-qubit unitary operation can be thought of as a rotation of the Bloch sphere. Let’s see how this works.\nA general rotation around a unit vector \\(\\vec{n} = (n_x, n_y, n_z)\\) by angle \\(\\theta\\) is given by \\[\nR_{\\vec{n}}(\\theta) = \\cos(\\theta/2)I - i\\sin(\\theta/2)(n_xX + n_yY + n_zZ).\n\\]\nFor example:\n\nRotation around z-axis: \\[ R_z(\\theta) = e^{-i\\theta Z/2} = \\begin{bmatrix} e^{-i\\theta/2} & 0 \\\\ 0 & e^{i\\theta/2} \\end{bmatrix} \\]\nRotation around x-axis: \\[ R_x(\\theta) = e^{-i\\theta X/2} = \\begin{bmatrix} \\cos(\\theta/2) & -i\\sin(\\theta/2) \\\\ -i\\sin(\\theta/2) & \\cos(\\theta/2) \\end{bmatrix} \\]\nRotation around y-axis: \\[R_y(\\theta) = e^{-i\\theta Y/2} = \\begin{bmatrix} \\cos(\\theta/2) & -\\sin(\\theta/2) \\\\ \\sin(\\theta/2) & \\cos(\\theta/2) \\end{bmatrix}\\]\n\nA remarkable fact is that any single-qubit unitary operation can be decomposed into three rotations around two different axes. This is known as the Euler angle decomposition: \\[\nU = e^{i\\alpha}R_z(\\phi)R_y(\\theta)R_z(\\psi)\n\\] where \\(\\alpha\\), \\(\\phi\\), \\(\\theta\\), and \\(\\psi\\) are real numbers. The global phase \\(e^{i\\alpha}\\) is often unimportant for quantum computing purposes.\n\n\n\n\n\n\nVisualizing Rotations\n\n\n\nThe Euler angle decomposition has a nice geometric interpretation:\n\nFirst rotation (\\(R_z(\\psi)\\)): Rotate around z-axis\nSecond rotation (\\(R_y(\\theta)\\)): Tilt to new latitude\nThird rotation (\\(R_z(\\phi)\\)): Rotate to final longitude\nGlobal phase (\\(e^{i\\alpha}\\)): Invisible in measurements\n\nThis is similar to how we specify points on Earth using latitude and longitude!\n\n\n\n\n2.2.2 The Phase Gate\nThe phase gate (often denoted as \\(S\\)) is another important single-qubit gate that adds a phase of \\(i\\) to the \\(\\ket{1}\\) state while leaving \\(\\ket{0}\\) unchanged:\n\\[\nS = \\begin{bmatrix} 1 & 0 \\\\ 0 & i \\end{bmatrix}\n\\]\nWhen acting on basis states: \\[\nS\\ket{0} = \\ket{0}, \\quad S\\ket{1} = i\\ket{1}\n\\]\nThe phase gate is equivalent to a \\(\\pi/2\\) rotation around the z-axis: \\(S = R_z(\\pi/2)\\). On the Bloch sphere, this corresponds to rotating a state by 90° around the z-axis.\n\n\n\n\n\n\nExample: Phase Gate on Superposition\n\n\n\nLet’s see what happens when we apply \\(S\\) to an equal superposition state:\n\\[\n\\begin{aligned}\nS\\ket{+} &= S\\left(\\frac{1}{\\sqrt{2}}(\\ket{0} + \\ket{1})\\right) \\\\\n&= \\frac{1}{\\sqrt{2}}(S\\ket{0} + S\\ket{1}) \\\\\n&= \\frac{1}{\\sqrt{2}}(\\ket{0} + i\\ket{1})\n\\end{aligned}\n\\]\nThis transforms \\(\\ket{+}\\) into \\(\\ket{+i}\\), rotating it from the positive x-axis to the positive y-axis on the Bloch sphere.\n\n\nThe phase gate is particularly important in quantum error correction and quantum algorithms where controlled phase operations are needed.\nMore generically, we can create any \\(R_z(\\phi)\\) gate to perform rotations about the \\(z\\)-axis (this is very useful for Shor’s algorithm). However, a common variant is the \\(T\\) gate, which is simply \\(R_z(\\pi/4)\\) and is one of the minimal components needed to achieve universal quantum computation.\n\n\n\n\n\n\nPhase gate leaves computational basis states alone\n\n\n\nNote that these gates only change superposition of computational basis states, so \\(S \\ket{0} = \\ket{0}\\) and \\(S\\ket{1} = i \\ket{1}\\). (Similarly for any gate made from rotations about the z-axis.)",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>The Qubit</span>"
    ]
  },
  {
    "objectID": "qubit.html#quantum-circuits",
    "href": "qubit.html#quantum-circuits",
    "title": "2  The Qubit",
    "section": "2.3 Quantum Circuits",
    "text": "2.3 Quantum Circuits\nNow that we’ve covered the key single-qubit operations, we can start to think about how to represent sequences of these operations graphically using quantum circuits. In quantum circuits:\n\nQubits are represented as horizontal lines (called “wires”, see Fig. 2.2).\nGates are boxes or symbols placed on these wires (see Fig. 2.3 and Fig. 2.4).\nTime flows from left to right.\nMeasurements are represented by meters (see Fig. 2.5).\n\nOften, unless we are preparing a specific state for an algorithm, we may leave off the states from the ends of the “wire.” This wire, Fig. 2.2, you can think of as the identity.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a) Identity on \\(\\ket{0}\\)\n\n\n\n\n\n\n\n\n\n\n\n(b) Identity on \\(\\ket{1}\\)\n\n\n\n\n\n\n\n\n\n\n\n(c) Identity on \\(\\ket{\\psi}\\)\n\n\n\n\n\n\n\nFig. 2.2: Lines representing the evolution of a qubit (no gates applied)\n\n\n\nWhile in quantum state evolution we apply operators right-to-left, the two operations \\(X \\ket{0} = \\ket{1}\\) and \\(Z \\ket{+} = \\ket{-}\\) are represented in Fig. 2.3.\n\n\n\n\n\n\nImportant\n\n\n\nThe Pauli operators are both unitary and Hermitian, so they perform as quantum gates (which require unitary as Section 1.3.3 stipulates) and as observables (as Section 1.3.2 stipulates).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a) Application of the \\(X\\) gate.\n\n\n\n\n\n\n\n\n\n\n\n(b) Application of the \\(Z\\) gate.\n\n\n\n\n\n\n\nFig. 2.3: Examples of the Pauli operators as gates.\n\n\n\nThe Hadamard and phase gates can also be mixed in, Fig. 2.4, and we can even introduce the meter symbol for measurements, Fig. 2.5.\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a) Application of the Hadamard gate.\n\n\n\n\n\n\n\n\n\n\n\n(b) Application of the phase gate\n\n\n\n\n\n\n\nFig. 2.4: Examples of the Hadamard and phase gates.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a) Will measure 1 with 100% probability\n\n\n\n\n\n\n\n\n\n\n\n(b) Will measure 1 with 50% probability\n\n\n\n\n\n\n\nFig. 2.5: Examples of measurements. The meter is assumed to be measuring in the computational basis unless otherwise noted (i.e., measuring the \\(Z\\) operator).\n\n\n\nWhenever measurements are performed, we will often transform to the computational basis \\(\\ket{0}\\) and \\(\\ket{1}\\) to perform a measurement. By playing tricks with unitary transformations, we can measure other observables by mixing unitaries and measurements of the computational basis; dependent on the platform, this may or may not be necessary. In terms of diagrams, you should assume meters are measurements in the computational basis unless it is noted otherwise.\n\n\n\n\n\n\nReading Quantum Circuits\n\n\n\nQuantum circuits are read from left to right, just like reading text. Each horizontal line represents a qubit’s journey through time, and the boxes show what operations happen and when.\nThe measurement symbol at the end indicates when we extract classical information from our quantum system.\n\n\nThese diagrams give us a powerful visual language for describing quantum computations. Even complex algorithms can be broken down into sequences of these basic operations.\n\n\n\n\n\n\nExample: Gate Sequences\n\n\n\nConsider applying \\(H\\) then \\(Z\\) then \\(H\\) to \\(\\ket{0}\\):\n\n\n\n\n\n\n\nFig. 2.6: Implementing an \\(X\\) gate with \\(Z\\) and \\(H\\).\n\n\n\n\n\\(H\\ket{0} = \\ket{+}\\) (move to +x axis)\n\\(Z\\ket{+} = \\frac{1}{\\sqrt{2}}(\\ket{0} - \\ket{1})\\) (rotate around z by 90°)\n\\(H(\\frac{1}{\\sqrt{2}}(\\ket{0} - \\ket{1})) = \\ket{1}\\) (move to -z axis)\n\nThis sequence effectively implements the \\(X\\) gate!",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>The Qubit</span>"
    ]
  },
  {
    "objectID": "qubit.html#noise-and-decoherence",
    "href": "qubit.html#noise-and-decoherence",
    "title": "2  The Qubit",
    "section": "2.4 Noise and decoherence",
    "text": "2.4 Noise and decoherence\nA large part of the course will consist of finding physical systems where we can identify certain states as \\(\\ket{0}\\) and \\(\\ket{1}\\), and then proceed to figure out how to perform the gates we need for quantum algorithms. In this way, this course could be called “two-level systems and where to find them.” However, these states are not pristine and so we need a way to talk about states that subject to noisy environments and loss of information.\nIn fact, environmental interactions can cause, amongst other issues:\n\nLoss of phase information (dephasing)\nLoss of energy (amplitude damping)\nRandom bit flips\n\nTo properly describe these noise processes, we need to move beyond pure state descriptions and introduce the density matrix formalism.\n\n2.4.1 The Density Matrix\nFor a pure quantum state \\(\\ket{\\psi}\\), the density matrix is defined as \\[\n\\rho = \\ket{\\psi}\\bra{\\psi}\n\\] For example, the computational basis states have density matrices: \\[\n\\ket{0}\\bra{0} = \\begin{bmatrix} 1 & 0 \\\\ 0 & 0 \\end{bmatrix}, \\quad\n\\ket{1}\\bra{1} = \\begin{bmatrix} 0 & 0 \\\\ 0 & 1 \\end{bmatrix}\n\\]\nThe density matrix also provides a convenient way to calculate expectation values of observables. For any observable \\(A\\), the expectation value is given by: \\[\n\\langle A \\rangle = \\tr(A\\rho)\n\\] For a pure state \\(\\ket{\\psi}\\), this reduces to our familiar expression: \\[\n\\tr(A\\ket{\\psi}\\bra{\\psi}) = \\bra{\\psi}A\\ket{\\psi}\n\\]\n\n\n\n\n\n\nExample: Measuring \\(Z\\) with the Density Matrix\n\n\n\nConsider measuring \\(Z\\) for the state \\(\\ket{+} = \\frac{1}{\\sqrt{2}}(\\ket{0} + \\ket{1})\\):\nThe density matrix is: \\[\n\\rho_+ = \\frac{1}{2}\\begin{bmatrix} 1 & 1 \\\\ 1 & 1 \\end{bmatrix}\n\\]\nUsing the formula for expecation values with \\(Z = \\begin{bmatrix} 1 & 0 \\\\ 0 & -1 \\end{bmatrix}\\): \\[\n\\langle Z \\rangle = \\tr(Z\\rho_+) = \\tr\\left(\\frac{1}{2}\\begin{bmatrix} 1 & 0 \\\\ 0 & -1 \\end{bmatrix}\\begin{bmatrix} 1 & 1 \\\\ 1 & 1 \\end{bmatrix}\\right) = 0\n\\]\nThis matches what we expect: \\(\\ket{+}\\) has equal probability of measuring \\(\\pm 1\\) for \\(Z\\).\n\n\nThe real power of density matrices comes from describing mixed states, which are statistical mixtures of pure states: \\[\n\\rho = \\sum_i p_i \\ket{\\psi_i}\\bra{\\psi_i}\n\\] where \\(p_i\\) are classical probabilities (\\(p_i \\geq 0\\), \\(\\sum_i p_i = 1\\)).\n\n\n\n\n\n\nProperties of Density Matrices\n\n\n\nAny valid density matrix must satisfy:\n\nHermiticity: \\(\\rho = \\rho^\\dagger\\)\nPositive semidefinite: \\(\\bra{\\phi}\\rho\\ket{\\phi} \\geq 0\\) for all \\(\\ket{\\phi}\\)\nUnit trace: \\(\\tr(\\rho) = 1\\)\nFor pure states: \\(\\tr(\\rho^2) = 1\\)\nFor mixed states: \\(\\tr(\\rho^2) &lt; 1\\)\n\n\n\n\nQuantum Operations with Density Matrices\nJust as we can evolve pure states with unitary operators, we can evolve density matrices. For a unitary operation \\(U\\), the density matrix transforms as: \\[\n\\rho \\rightarrow U\\rho U^\\dagger\n\\] This preserves all the properties of the density matrix we discussed above.\nWhen we make a measurement, we use projection operators \\(\\{P_m\\}\\) (like \\(\\ket{0}\\bra{0}\\) and \\(\\ket{1}\\bra{1}\\) for measuring in the computational basis). The probability of getting outcome \\(m\\) is: \\[\np(m) = \\tr(P_m \\rho)\n\\] After measuring and getting outcome \\(m\\), the state “collapses” to: \\[\n\\rho_m = \\frac{P_m \\rho P_m}{\\tr(P_m \\rho)}\n\\] where the denominator ensures the trace remains 1.\n\n\n\n\n\n\nQuantum Channels\n\n\n\nThe density matrix formalism really shines when describing general quantum evolution, including noise. Any physical process (unitary or not) can be described by a quantum channel \\(\\mathcal{E}\\): \\[\n\\rho \\rightarrow \\mathcal{E}(\\rho) = \\sum_k E_k \\rho E_k^\\dagger\n\\] The operators \\(E_k\\) (called Kraus operators) satisfy \\(\\sum_k E_k^\\dagger E_k = I\\) to preserve probability. This includes both ideal unitary evolution (one \\(E_k = U\\)) and noise processes (multiple \\(E_k\\)), as we’ll see in the next section.\n\n\n\n\nDensity Matrices and the Bloch Sphere\nThe density matrix formalism provides a beautiful geometric picture when combined with the Bloch sphere representation in Section 2.2. While pure states live on the surface of the Bloch sphere, mixed states live inside it. Any density matrix for a single qubit can be written as: \\[\n\\rho = \\frac{1}{2}(I + \\vec{r}\\cdot\\vec{\\sigma})\n\\] where \\(\\vec{r} = (r_x, r_y, r_z)\\) is called the Bloch vector and \\(\\vec{\\sigma} = (X,Y,Z)\\) are the Pauli matrices.\nThe length of \\(\\vec{r}\\) determines how mixed the state is:\n\nFor pure states, \\(|\\vec{r}| = 1\\) (surface of sphere)\nFor mixed states, \\(|\\vec{r}| &lt; 1\\) (inside sphere)\nFor the maximally mixed state, \\(\\vec{r} = 0\\) (center of sphere)\n\nThis gives us an intuitive picture of decoherence: noise processes like dephasing and bit flips move the Bloch vector inward from the surface, representing the loss of quantum information. The maximally mixed state at the center represents complete loss of information–equal probabilities for all measurement outcomes.\n\n\n\n\n\n\nConnection to Purity\n\n\n\nThe length of the Bloch vector is directly related to the purity \\(\\tr(\\rho^2)\\) we discussed earlier: \\[\n\\tr(\\rho^2) = \\frac{1 + |\\vec{r}|^2}{2}\n\\] This confirms that pure states (\\(|\\vec{r}| = 1\\)) have purity 1, while mixed states have purity less than 1.\n\n\n\n\n\n2.4.2 Modeling Noise\nA full discussion of different quantum channels can be found in  [3]. Here, we discuss some of the ones relevant for loss of quantum information.\nThe language of density matrices allows us to describe some of the errors that can occur in a precise manner\n\nRandom bit-flips\nIf there is probability \\(p\\) that a bit is flipped, we can encode this within a change of the density matrix: \\[\n\\rho \\rightarrow (1-p)\\rho + p X\\rho X,\n\\] where the first term describes the probability that the density matrix remains unchanged and the second describe the process of randomly flipping a bit.\n\n\nDephasing\nAs we’ve already mentioned the phase between \\(\\ket{0}\\) and \\(\\ket{1}\\) is useful information that we will take advantage of. However, some physical processes can scramble this phase in a way that could be inherently difficult to parse, in that case we can describe these processes with “dephasing” \\[\n\\rho \\rightarrow (1-p)\\rho + p Z \\rho Z.\n\\] This process has a clear action on \\(\\rho\\) when \\(p=1/2\\). To illustrate this, consider \\(\\ket{\\psi} = \\alpha \\ket{0} + \\beta \\ket{1}\\), this has a probability of measuring \\(0\\) of \\(|\\alpha|^2\\) and a probabilty of measuring \\(1\\) of \\(|\\beta|^2\\), but there is also phase information between \\(\\alpha\\) and \\(\\beta\\) that tells us where on the Bloch sphere the state is located. Dephasing will eliminate this phase information.\nTo see this, the full density matrix before we apply dephasing is \\[\n\\rho = \\begin{bmatrix} |\\alpha|^2 & \\alpha\\beta^* \\\\ \\alpha^*\\beta & |\\beta|^2 \\end{bmatrix},\n\\] and after dephasing we will have the density matrix \\[\n\\frac12 \\rho + \\frac12 Z \\rho Z = \\begin{bmatrix} |\\alpha|^2 & 0 \\\\ 0 & |\\beta|^2 \\end{bmatrix}.\n\\] The off-diagonal components carried the relative phase information and it is now entirely lost, leaving us with a classical mixture of \\(\\ket{0}\\) and \\(\\ket{1}\\)\n\n\n\n\n\n\nMeasurement as Dephasing\n\n\n\nThis process of losing phase information is exactly what happens when we measure a quantum state in a particular basis! When we measure in the computational basis (\\(\\{\\ket{0}, \\ket{1}\\}\\)), we are effectively performing complete dephasing - we destroy all phase information between the basis states and are left with only the classical probabilities. This is why measurement is often described as “collapsing” the quantum state into classical information.\nThis connection between measurement and dephasing illustrates a fundamental aspect of quantum mechanics: the act of gaining classical information about a quantum system necessarily destroys some of its quantum properties, as formalized in the measurement postulates we discussed earlier.\n\n\n\n\n\n\n\n\nExample: Dephasing of a Superposition State\n\n\n\nConsider the state \\(\\ket{+} = \\frac{1}{\\sqrt{2}}(\\ket{0} + \\ket{1})\\) under dephasing:\nInitial density matrix: \\[\n\\rho_0 = \\frac{1}{2}\\begin{bmatrix} 1 & 1 \\\\ 1 & 1 \\end{bmatrix}\n\\]\nAfter dephasing with probability \\(p\\): \\[\n\\rho(p) = \\frac{1}{2}\\begin{bmatrix} 1 & (1-2p) \\\\ (1-2p) & 1 \\end{bmatrix}\n\\]\nComplete dephasing (\\(p=\\frac{1}{2}\\)) yields the maximally mixed state: \\[\n\\rho(\\tfrac{1}{2}) = \\frac{1}{2}\\begin{bmatrix} 1 & 0 \\\\ 0 & 1 \\end{bmatrix}\n\\]\n\n\n\n\nDepolarizing\nThe depolarizing channel represents one of the most severe forms of noise in quantum systems, often considered the “worst-case scenario” for quantum information. This channel transforms any input state into a mixture of itself and the maximally mixed state: \\[\n\\rho \\rightarrow (1-p)\\rho + p \\frac{I}{2},\n\\] where \\(p\\) represents the probability of depolarization. When \\(p=1\\), the state becomes completely mixed regardless of the input: \\[\n\\rho \\rightarrow \\frac{1}{2}I.\n\\]\nNote that this has eliminated any information about \\(\\ket{\\psi}\\)!\n\n\n\n\n\n\nExample: The Pauli Twirl\n\n\n\nAn interesting way to understand the depolarizing channel is through what’s called the “Pauli twirl”. The depolarizing channel can be written as a random application of Pauli operators: \\[\n\\rho \\rightarrow (1-p)\\rho + \\frac{p}{3}(X\\rho X + Y\\rho Y + Z\\rho Z).\n\\]\nThis means we can implement depolarizing noise by randomly applying X, Y, or Z gates with probability \\(p/3\\) each. This is particularly useful in quantum error correction, where we often want to simulate noise in a way that’s easy to analyze.\n\n\n\n\nAmplitude Damping\nIn many physical systems, one can lose information by having emission of energy. Physically, this could be an atom in some energy level and it emits a photon, falling to a lower energy level. One can imagine a process like this occuring with an operator \\[\nE_0 = \\sqrt{\\gamma} \\ket{0} \\bra{1},\n\\] which describes the process of taking an occupied state \\(\\ket{1}\\) and transforming it to \\(\\ket{0}\\) with probability \\(\\gamma\\). To fully encode this into a change in the density matrix, we need one other operator: the chance that nothing happens. A natural guess would be \\[\nE_1 = \\ket{0}\\bra{0} + \\sqrt{1-\\gamma} \\ket{1}\\bra{1},\n\\] which describes that there is unit probability of remaining \\(\\ket{0}\\) and probaiblity \\(1-\\gamma\\) of remaining in \\(\\ket{1}\\) if you start there.\nThe full operation on the density matrix is then \\[\n\\rho \\rightarrow E_1 \\rho E_1^\\dagger + E_0 \\rho E_0^\\dagger\n\\]\n\n\n\n\n\n\nExample: Amplitude Damping in Action\n\n\n\nLet’s see how amplitude damping affects a simple superposition state. Consider the initial state \\[\n\\ket{\\psi} = \\frac{1}{\\sqrt{2}}(\\ket{0} + \\ket{1}),\n\\] which has density matrix \\[\n\\rho = \\frac{1}{2}\\begin{bmatrix} 1 & 1 \\\\ 1 & 1 \\end{bmatrix}.\n\\]\nAfter applying amplitude damping with probability \\(\\gamma\\), the state becomes \\[\n\\begin{aligned}\n\\rho' &= E_1 \\rho E_1^\\dagger + E_0 \\rho E_0^\\dagger \\\\\n&= \\frac{1}{2}\\begin{bmatrix} 1+\\gamma & \\sqrt{1-\\gamma} \\\\ \\sqrt{1-\\gamma} & 1-\\gamma \\end{bmatrix}.\n\\end{aligned}\n\\]\nWe can see that:\n\nThe probability of being in \\(\\ket{1}\\) decreases by \\(\\gamma\\)\nThe probability of being in \\(\\ket{0}\\) increases by \\(\\gamma\\)\nThe off-diagonal coherence terms decay by \\(\\sqrt{1-\\gamma}\\)\n\nWhen \\(\\gamma = 1\\) (complete damping), the state becomes \\[\n\\rho' = \\begin{bmatrix} 1 & 0 \\\\ 0 & 0 \\end{bmatrix} = \\ket{0}\\bra{0},\n\\] representing complete relaxation to the ground state.\n\n\n\n\nErasure Channel\nAnother important quantum channel is the erasure channel, which models the loss of a qubit to other accessible states. Unlike amplitude damping, where information leaks gradually, the erasure channel represents a complete loss of the qubit with probability \\(\\epsilon\\). When this happens, the qubit is replaced by an “error state” that we denote as \\(\\ket{e}\\). Importantly, \\(\\ket{e}\\) exists in a different part of the Hilbert space than our qubit states - it’s an additional state that flags that erasure has occurred.\n\n\n\n\n\n\nOrthogonality of Error State\n\n\n\nThe error state \\(\\ket{e}\\) is orthogonal to both \\(\\ket{0}\\) and \\(\\ket{1}\\), meaning \\(\\braket{e|0} = \\braket{e|1} = 0\\). This is crucial as it represents a state completely outside our original qubit space but still within the system itself.\n\n\nThe erasure can then be represented by \\[\n\\rho \\mapsto (1 - \\epsilon)\\rho + \\epsilon \\ket{e}\\bra{e}.\n\\]\nIn particular, this process\n\nPreserves the state with probability \\(1-\\epsilon\\)\nErases it completely with probability \\(\\epsilon\\), replacing it with the error state \\(\\ket{e}\\)\n\n\n\n\n\n\n\nExample: Erasure Channel in Action\n\n\n\nSince the erasure channel operates in an enlarged Hilbert space that includes the error state (in this case, making it 3-dimensional), let’s consider our superposition state embedded in this expanded space: \\[\n\\ket{\\psi} = \\frac{1}{\\sqrt{2}}(\\ket{0} + \\ket{1}) = \\frac{1}{\\sqrt{2}}(\\ket{0} + \\ket{1}) = \\frac{1}{\\sqrt{2}}\\begin{bmatrix} 1 \\\\ 1 \\\\ 0 \\end{bmatrix}.\n\\] After the erasure channel acts, the state becomes a mixed state: \\[\n\\rho' = (1-\\epsilon)\\begin{bmatrix}\n1/2 & 1/2 & 0 \\\\\n1/2 & 1/2 & 0 \\\\\n0 & 0 & 0\n\\end{bmatrix} + \\epsilon\\begin{bmatrix}\n0 & 0 & 0 \\\\\n0 & 0 & 0 \\\\\n0 & 0 & 1\n\\end{bmatrix}\n= \\begin{bmatrix}\n\\frac{1-\\epsilon}{2} & \\frac{1-\\epsilon}{2} & 0 \\\\\n\\frac{1-\\epsilon}{2} & \\frac{1-\\epsilon}{2} & 0 \\\\\n0 & 0 & \\epsilon\n\\end{bmatrix}\n\\] This represents that with probability \\(1-\\epsilon\\) we still have our original state in the upper-left \\(2\\times2\\) block, but with probability \\(\\epsilon\\) we have completely lost it to the error state, represented by the 1 in the bottom-right corner.\n\n\nThe erasure channel is particularly important in quantum communication and error correction because the error state exists within the system Hilbert space itself (not the environment). This additional state in the system allows us to track and flag when errors occur–making it especially useful for quantum error correction protocols, unlike other noise channels where the errors are unknown and harder to detect.\n\n\n\n2.4.3 Physical Qubit Implementations\nThe quest for building practical quantum computers has led to several different approaches for implementing qubits. Each implementation aims to create a physical system that can reliably represent quantum states and allow for precise control and manipulation. We will explore in detail later what is needed for a good quantum device, but give a brief overview here of what the devices are.\n\nSuperconducting Qubits\n\nQubit are energy levels of charge or flux within a superconducting circuit.\nBased on superconducting circuits using Josephson junctions.\nOperate at extremely low temperatures (~20 mK).\nUsed by: IBM, Google, Rigetti.\n\n\n\nTrapped Ion Qubits\n\nQubits are electronic or nuclear states of individual ions\nIons held in electromagnetic traps, manipulated by lasers\nUsed by: IonQ, Honeywell-Quantinuum\n\n\n\nPhotonic Qubits\n\nQubits are properites of light (e.g., polarization)\nCan operate at room temperature\nUsed by: PsiQuantum, Xanadu\n\n\n\nSemiconductor Quantum Dots\n\nQubits can be encoded using either:\n\ncharge states (electron occupying different quantum dots)\nspin states (up/down spin states of an electron)\n\nCreated by confining electrons in semiconductor nanostructures\nOften called “artificial atoms” due to their discrete energy levels\nActive research at: Intel, TU Delft, Princeton, UNSW, CEA-Leti\n\n\n\nNV Centers in Diamond\n\nThe nitrogen vacancy defects in diamond provide energy levels accessible with light.\nCan operate at room temperature\nApplications in quantum sensing and networking\n\n\n\nTopological Qubits\n\nQubits are non-local and topologically protected states within an exotic (topological) state of matter.\nMost promising candidate: Majorana zero modes\nCurrent Status:\n\nActive research at Microsoft and Delft\nRecent progress in identifying Majorana signatures in nanowires\nDebate continues over experimental evidence\n\n\nAs we’ll discuss, the “perfect” qubit would combine long coherence times, fast gates, high fidelity, easy coupling to other qubits, and straightforward scalability. While each implementation has made significant progress, achieving all these properties simultaneously remains a major challenge in the field.\n\n\n\n\n[1] W. K. Wootters and W. H. Zurek, A single quantum cannot be cloned, Nature 299, 802 (1982).\n\n\n[2] S. Bravyi and A. Kitaev, Universal quantum computation with ideal Clifford gates and noisy ancillas, Physical Review A 71, 022316 (2005).\n\n\n[3] M. M. Wilde, Quantum Information Theory, 2nd ed (Cambridge university press, Cambridge, 2017).",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>The Qubit</span>"
    ]
  },
  {
    "objectID": "qubit.html#footnotes",
    "href": "qubit.html#footnotes",
    "title": "2  The Qubit",
    "section": "",
    "text": "Magic is a technical term in quantum computing, though we’re using it in a colloquial sense here, see  [2].↩︎\nIn some literature, these are matrices are denoted by \\(\\sigma_{x}\\), \\(\\sigma_y\\), and \\(\\sigma_z\\) and related to spin operators via \\(S_i =\\frac12 \\sigma_i\\). This insight can help bridge the idea of these operators and the Bloch sphere.↩︎\nThe divide-by-two for the angles will become clear as we go through this section.↩︎",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>The Qubit</span>"
    ]
  },
  {
    "objectID": "multiple_qubits.html",
    "href": "multiple_qubits.html",
    "title": "3  Multiple Qubits",
    "section": "",
    "text": "3.1 Tensor Products and the multi-qubit Hilbert space\nPreviously in Chapter 2 we discussed in detail how to understand a single qubit. While we saw some basic features, such as superposition and relative phase, it has not been apparent yet what we can do with these features. The power of these will really be unlocked by putting multiple qubits together. We will also begin to see hints of quantum entanglement.\nHowever, there is just a practical concern: How much information can we store in a single qubit? With precise control, we have our answer in Section 2.2: the angles \\(\\theta\\) and \\(\\phi\\) on the Bloch sphere. Since algorithms are bit more greedy than that, we need to extend our space and the natural way to do that is to add more qubits. Of course, classically, we operate with many bits: Floats (real numbers) on most computers use 64 bits, and we often add, substract, multiply a lot of these numbers. But classically, when we have, for instance, two bits, there are four discrete states 00, 01, 10, and 11. As we will analyze in detail, quantum mechanically these will be four basis states that can make up a general quantum wave function \\[\n\\ket{\\psi} = \\alpha \\ket{00} + \\beta \\ket{01} + \\gamma \\ket{10} + \\delta \\ket{11}.\n\\tag{3.1}\\]\nThe equation above gives us an idea for how we ought to combine qubits. The tensor product will formalize this, but we will build it up “intuitively.”\nImagine we have one big operator called “read-out” or \\(\\mathcal R\\); this operator will measure all of the qubits in the system, and its value will tell us exactly what the state of the system is in terms of the computational basis.\nHowever, this operator \\(\\mathcal R\\) must be Hermitian to be a physical observable, and as a result its eigenstates span our Hilbert space. Well, upon readout, we know that each qubit can be in one of two states \\(b_i = 0\\) or \\(1\\), and if we have \\(i = 1, \\ldots, N\\) qubits, there are \\(2^N\\) possibilities.\nWe will return to this, but let us linger on two qubits. Notice that we can obtain the above states with an operation called the tensor product.\nThis multiplication table is how we go from basis sets of single qubits to the basis set of two qubits. Very often, we will drop the \\(\\otimes\\) and simply write \\[\n\\ket{b_1 b_2} \\equiv \\ket{b_1} \\otimes \\ket{b_2}.\n\\]\nSimilarly, we can build up three qubit states by taking the tensor product of two-qubit states with a single qubit:\nagain we can define \\[\n\\ket{b_1 b_2 b_3} = \\ket{b_1 b_2} \\otimes \\ket{b_3},\n\\] and we proceed once more\nAs we can see, every time we add a new qubit, the dimension of the space is multiplied by two. In general, we can can break \\(N\\)-qubits in the computational basis as \\[\n\\ket{b_1 b_2 \\cdots b_N} = \\ket{b_1} \\otimes \\ket{b_2} \\otimes \\cdots \\otimes \\ket{b_N}\n\\] where \\(b_j = 0\\) or \\(1\\). Since this is a basis, we can “count” the number of basis states to determine the dimension of the space to obtain for the Hilbert space of \\(N\\)-qubits \\(\\mathcal H_N\\), \\[\n\\dim \\mathcal H_N = 2^N.\n\\] Therefore, a general quantum state of \\(N\\) qubits can be written as a superposition of all possible computational basis states: \\[\n\\ket{\\psi} = \\sum_{b_1,\\ldots,b_N = 0,1} \\psi_{b_1\\cdots b_N} \\ket{b_1\\cdots b_N}\n\\] where \\(\\psi_{b_1\\cdots b_N}\\) are complex coefficients satisfying the normalization condition \\[\n\\sum_{b_1,\\ldots,b_N = 0,1} |\\psi_{b_1\\cdots b_N}|^2 = 1.\n\\] This means that to fully specify a quantum state of \\(N\\) qubits, we need \\(2^N\\) complex numbers (subject to normalization), which illustrates both the power and challenge of quantum computing - the exponential growth in the state space allows for massive parallel processing but also makes classical simulation difficult.\nThe exponential growth in the state space has important implications for simulating quantum systems on classical computers. While we need \\(2^N\\) complex numbers to specify an arbitrary quantum state, the situation becomes even more demanding when we consider operations on these states:\nThis exponential scaling is why classical computers struggle to simulate large quantum systems - the memory and computational requirements become overwhelming. For example:\nHowever, it’s important to note that not all quantum computations require storing and manipulating the full state space. Many practical quantum algorithms and simulations exploit special properties:\nNevertheless, the ability to access and manipulate this exponentially large state space can help us perform computations that classical computers would struggle with.\nBefore we run head first into entanglement, let’s take a minute to just do some counting to see that we are going to run into some trouble. For a single qubit, we have two complex numbers \\(\\ket{\\psi} = \\alpha\\ket0 + \\beta \\ket1\\), but we need to normalize them \\(|\\alpha|^2 + |\\beta|^2=1\\) and remove a phase. Thus, we have reduced our 2 complex numbers (= 4 real numbers) down to 4-1-1=2 real numbers. This is made explicit with the Bloch sphere where two real numbers \\((\\theta,\\phi)\\) completely characterize the state. Therefore, do we only need \\(2\\times 2=4\\) real numbers to describe a 4 qubit state? Well, let’s count, we can see from Eq. 3.1 that we have 4 complex numbers (= 8 real numbers). But we must also impose normalization and remove an overall phase, reducing us down to 8-1-1 = 6 real numbers. But \\(6&gt;4\\); this is our first hint of something happening in our quantum system, we need more numbers to describe all of the states in a two qubit system than simply what we needed for two separate qubits.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Multiple Qubits</span>"
    ]
  },
  {
    "objectID": "multiple_qubits.html#tensor-products-and-the-multi-qubit-hilbert-space",
    "href": "multiple_qubits.html#tensor-products-and-the-multi-qubit-hilbert-space",
    "title": "3  Multiple Qubits",
    "section": "",
    "text": "Two-Qubit Readout\n\n\n\nThe readout operator \\(\\mathcal{R}\\) maps the two-qubit basis states to unique numbers:\n\n\\(\\mathcal{R}\\ket{00} = 0 \\ket{00}\\)\n\\(\\mathcal{R}\\ket{01} = 1 \\ket{01}\\)\n\\(\\mathcal{R}\\ket{10} = 2 \\ket{10}\\)\n\\(\\mathcal{R}\\ket{11} = 3 \\ket{11}\\)\n\nThis binary-to-decimal conversion helps us uniquely identify each computational basis state.\n\n\n\n\n\n\n\n\\(\\otimes\\)\n\\(\\ket{0}\\)\n\\(\\ket{1}\\)\n\n\n\n\n\\(\\ket{0}\\)\n\\(\\ket{0} \\otimes \\ket{0}\\)\n\\(\\ket{0} \\otimes \\ket{1}\\)\n\n\n\\(\\ket{1}\\)\n\\(\\ket{1}\\otimes \\ket{0}\\)\n\\(\\ket{1}\\otimes \\ket{0}\\)\n\n\n\n\n\n\n\n\n\\(\\otimes\\)\n\\(\\ket{0}\\)\n\\(\\ket{1}\\)\n\n\n\n\n\\(\\ket{00}\\)\n\\(\\ket{00} \\otimes \\ket{0}\\)\n\\(\\ket{00} \\otimes \\ket{1}\\)\n\n\n\\(\\ket{01}\\)\n\\(\\ket{01} \\otimes \\ket{0}\\)\n\\(\\ket{01} \\otimes \\ket{1}\\)\n\n\n\\(\\ket{10}\\)\n\\(\\ket{10} \\otimes \\ket{0}\\)\n\\(\\ket{10} \\otimes \\ket{1}\\)\n\n\n\\(\\ket{11}\\)\n\\(\\ket{11} \\otimes \\ket{0}\\)\n\\(\\ket{11} \\otimes \\ket{1}\\)\n\n\n\n\n\n\n\n\n\n\n\n\n\\(\\otimes\\)\n\\(\\ket{0}\\)\n\\(\\ket{1}\\)\n\n\n\n\n\\(\\ket{000}\\)\n\\(\\ket{000} \\otimes \\ket{0}\\)\n\\(\\ket{000} \\otimes \\ket{1}\\)\n\n\n\\(\\ket{001}\\)\n\\(\\ket{001} \\otimes \\ket{0}\\)\n\\(\\ket{001} \\otimes \\ket{1}\\)\n\n\n\\(\\ket{010}\\)\n\\(\\ket{010} \\otimes \\ket{0}\\)\n\\(\\ket{010} \\otimes \\ket{1}\\)\n\n\n\\(\\ket{011}\\)\n\\(\\ket{011} \\otimes \\ket{0}\\)\n\\(\\ket{011} \\otimes \\ket{1}\\)\n\n\n\\(\\ket{100}\\)\n\\(\\ket{100} \\otimes \\ket{0}\\)\n\\(\\ket{100} \\otimes \\ket{1}\\)\n\n\n\\(\\ket{101}\\)\n\\(\\ket{101} \\otimes \\ket{0}\\)\n\\(\\ket{101} \\otimes \\ket{1}\\)\n\n\n\\(\\ket{110}\\)\n\\(\\ket{110} \\otimes \\ket{0}\\)\n\\(\\ket{110} \\otimes \\ket{1}\\)\n\n\n\\(\\ket{111}\\)\n\\(\\ket{111} \\otimes \\ket{0}\\)\n\\(\\ket{111} \\otimes \\ket{1}\\)\n\n\n\n\n\n\n\n\n\n\nTwo-qubit wave functions and entanglement\n\n\n\nA general two-qubit wave function can be written as \\[\n\\ket{\\psi} = \\psi_{00}\\ket{00} + \\psi_{01}\\ket{01} + \\psi_{10}\\ket{10} + \\psi_{11}\\ket{11}\n\\] where \\(|\\psi_{00}|^2 + |\\psi_{01}|^2 + |\\psi_{10}|^2 + |\\psi_{11}|^2 = 1\\). When the two qubits are independent (a product state), we can write this as a tensor product of individual qubit states: \\[\n\\begin{aligned}\n\\ket{\\psi} & = (\\alpha_1\\ket{0} + \\beta_1\\ket{1}) \\otimes (\\alpha_2\\ket{0} + \\beta_2\\ket{1}) \\\\ & = \\alpha_1\\alpha_2\\ket{00} + \\alpha_1\\beta_2\\ket{01} + \\beta_1\\alpha_2\\ket{10} + \\beta_1\\beta_2\\ket{11}\n\\end{aligned}\n\\]\nHowever, not all two-qubit states can be written as such a product! States that cannot be factored into a tensor product of individual qubit states are called entangled states - a crucial quantum resource we’ll explore later.\n\n\n\n\nTo represent an arbitrary quantum operation (unitary evolution) on \\(N\\) qubits, we need a \\(2^N \\times 2^N\\) unitary matrix. This requires storing and manipulating \\(2^{2N}\\) complex numbers.\nEven to compute the probability of a measurement outcome, we need to perform operations involving all \\(2^N\\) amplitudes.\n\n\n\n10 qubits: \\(2^{10} = 1,024\\) amplitudes, \\(2^{20} \\approx 1\\) million matrix elements\n30 qubits: \\(2^{30} \\approx 1\\) billion amplitudes, \\(2^{60} \\approx 10^{18}\\) matrix elements\n50 qubits: \\(2^{50} \\approx 10^{15}\\) amplitudes, \\(2^{100} \\approx 10^{30}\\) matrix elements\n\n\n\nSome quantum states have special structure (like product states) that allow more efficient representations\nMany quantum operations act locally or have special symmetries that reduce the computational complexity\nSome quantum algorithms can be simulated using specialized techniques that avoid storing the full state vector\n\n\n\n\n\n\n\n\nClassical simulation vs. quantum measurement\n\n\n\nWhen simulating quantum systems on classical computers, we have direct access to the full state vector - all the complex amplitudes \\(\\psi_{b_1\\cdots b_N}\\). This gives us complete information about the quantum state, allowing us to calculate any property without performing repeated measurements.\nIn contrast, real quantum computers are bound by the measurement postulates of quantum mechanics (Postulate II, Section 1.3.2). Each measurement:\n\nCollapses the quantum state\nOnly returns eigenvalues of the measured observable\nMust be repeated many times to estimate expectation values and state properties\n\nThis limitation of quantum hardware is why techniques like quantum state tomography are necessary - reconstructing the full quantum state requires performing many different measurements on multiple copies of the same state. Classical simulation sidesteps this fundamental quantum constraint, though at the cost of exponential classical resources.\n\n\n\n\n\n\n\n\nExample: Building up three-qubit states\n\n\n\nConsider how we build up the state \\(\\ket{101}\\):\n\nStart with first two qubits: \\(\\ket{10}\\)\nTensor with third qubit: \\(\\ket{10} \\otimes \\ket{1}\\)\nThis gives: \\(\\ket{101}\\)\n\nWe can verify this matches our counting:\n\nFirst qubit: \\(\\ket{1}\\) (second basis state)\nSecond qubit: \\(\\ket{0}\\) (first basis state)\nThird qubit: \\(\\ket{1}\\) (second basis state)\n\nTherefore in binary: 101, which is state number 5 in our computational basis (counting from 0).\n\n\n\n\n\n\n\n\n\nMathematical Note: State Space Geometry\n\n\n\nFor the mathematically inclined: The physical state space of an N-qubit system is complex projective space \\(\\mathbb{CP}^{2^N-1}\\). For two qubits, this means \\(\\mathbb{CP}^3\\), which is fundamentally different from \\(\\mathbb{CP}^1 \\times \\mathbb{CP}^1\\) (the space of two separate qubits). This geometric fact underlies why we need more parameters to describe entangled states - the state space has a richer structure than just the product of individual qubit spaces.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Multiple Qubits</span>"
    ]
  },
  {
    "objectID": "multiple_qubits.html#entanglement",
    "href": "multiple_qubits.html#entanglement",
    "title": "3  Multiple Qubits",
    "section": "3.2 Entanglement",
    "text": "3.2 Entanglement\nEntanglement is one of the most important phenomena in quantum mechanics without a clear classical antecedent. The term was first coined by Schrödinger in 1935  [1] in response to a famous paper by Einstein, Podolsky, and Rosen (EPR)  [2]. It represents quantum correlations between particles that cannot be explained by a simple “lack of knowledge” by the observer. To get around this, it was thought there must be “hidden variables” to make quantum mechanics complete; thus, EPR used these quantum correlations to argue that quantum mechanics must be incomplete. Quantum mechanics appeared to allow “spooky action at a distance” that violated their ideas of locality and reality.\nHowever, in 1964, John Stewart Bell  [3] showed that quantum mechanics predicts correlations between entangled particles that are mathematically impossible to explain with any local hidden variable theory. Subsequent experiments have repeatedly confirmed these “Bell inequality violations,” demonstrating that entanglement represents a fundamentally new kind of physical relationship not reducible to classical correlations (early experiments include  [4] and  [5]).\nThe existence of entanglement suggests that the quantum wave function represents more than just our knowledge about measurement probabilities - it appears to be a real physical object. More recent work by Matthew Pusey, Jonathan Barrett, and Terry Rudolph  [6] has strengthened this view through their “PBR theorem,” which shows that if quantum predictions are correct, then quantum states must be physically real rather than merely statistical.\n\n\n\n\n\n\nReality of the Wave Function\n\n\n\nThe PBR theorem (2012)  [6] tells us something deep about quantum mechanics. To quote the paper,\n\nIn conclusion, we have presented a no-go theorem, which—modulo assumptions—shows that models in which the quantum state is interpreted as mere information about an objective physical state of a system cannot reproduce the predictions of quantum theory. The result is in the same spirit as Bell’s theorem, which states that no local theory can reproduce the predictions of quantum theory.\n\nThis provides strong support for viewing entanglement as a genuine physical phenomenon rather than just a limitation of our knowledge.\n\n\nLet’s explore what entanglement means mathematically and physically.\n\n3.2.1 Bell States and Non-local Correlations\nOne of the simplest cases of quantum entanglement is the Bell state \\[\n|\\Phi^+\\rangle = \\frac{|00\\rangle + |11\\rangle}{\\sqrt{2}}\n\\tag{3.2}\\]\nThis state exhibits perfect correlations that persist regardless of the physical separation between the qubits. When we measure the first qubit:\n\nIf we get \\(|0\\rangle\\), the state collapses to \\(|00\\rangle\\)\nIf we get \\(|1\\rangle\\), the state collapses to \\(|11\\rangle\\)\n\nThe remarkable feature is that measuring either qubit instantly determines the state of the other qubit, even if they are separated by vast distances. For example:\n\nCreate \\(|\\Phi^+\\rangle\\) and separate the qubits by sending one to Earth and one to Mars\nMeasure the Earth qubit → get result 0 or 1 with 50% probability\nWe know with 100% certainty that the Mars qubit will be measured to give the same result.\nThis happens faster than light could travel between the qubits.\n\n\n\n\n\n\n\nNo faster-than-light communication\n\n\n\nWhile entanglement appears to create “spooky action at a distance,” it cannot be used to transmit information faster than light. This is because:\n\nThe measurement results are random\nThe person with the second qubit needs classical information about the first measurement to interpret their results\nThis classical information is still limited by the speed of light\n\n\n\n\n\n\n\n\n\nBell state properties are basis independence\n\n\n\nA remarkable property of the Bell state \\(|\\Phi^+\\rangle\\) is that these perfect correlations persist no matter what basis we measure in. If we measure the first qubit in any basis and get some state \\(|\\psi\\rangle\\), the second qubit will always be found in state \\(|\\psi\\rangle\\) when measured in the same basis.\nFor example, if we measure the first qubit in the \\(X\\) basis: - If we get \\(|+\\rangle\\), the state collapses to \\(|{+}{+}\\rangle\\) - If we get \\(|-\\rangle\\), the state collapses to \\(|{-}{-}\\rangle\\)\nThis is because we can rewrite \\(|\\Phi^+\\rangle\\) in any basis and it maintains the same form: \\[\n|\\Phi^+\\rangle = \\frac{|00\\rangle + |11\\rangle}{\\sqrt{2}} = \\frac{|{+}{+}\\rangle + |{-}{-}\\rangle}{\\sqrt{2}}\n\\]\nThis is true for any basis, not just \\(Z\\) and \\(X\\).\n\n\nThese non-local correlations are fundamentally different from classical correlations, but how can we see that? The key ends up being: measurements that show quantum correlations and was Bell’s central insight  [3]. Instead of just looking at measurements of \\(Z\\) which are easily explained by a classical hidden variable, also perform measurements at other angles of the Bloch sphere.\n\n\n\n\n\n\nMermin’s Example\n\n\n\nTo see a simple example, read  [7]. The essence of the idea presented there is to measure three different observables with the Bell state in Eq. 3.2, \\[\nZ, \\quad -\\frac12 Z + \\frac{\\sqrt3}{2}X, \\quad -\\frac12 Z - \\frac{\\sqrt{3}}{2}X,\n\\] with the results from these three measurements, there is no way to use classical probabilities of measurement outcomes to account for the distribution of results.\n\n\n\n\n\n3.2.2 Mathematical definition and separability\nA multi-qubit quantum state is entangled if and only if it cannot be written as a tensor product of individual qubit states1. For a two-qubit pure state \\(|\\psi\\rangle\\), this means there do not exist single-qubit states \\(|\\phi_1\\rangle\\) and \\(|\\phi_2\\rangle\\) such that:\n\\[\n|\\psi\\rangle = |\\phi_1\\rangle \\otimes |\\phi_2\\rangle\n\\]\nFor a general two-qubit state \\(|\\psi\\rangle = \\alpha|00\\rangle + \\beta|01\\rangle + \\gamma|10\\rangle + \\delta|11\\rangle\\), there is a simple condition for separability: the state is separable if and only if the determinant of its coefficient matrix is zero:\n\\[\n\\begin{vmatrix}\n\\alpha & \\beta \\\\\n\\gamma & \\delta\n\\end{vmatrix} = \\alpha\\delta - \\beta\\gamma = 0\n\\]\nThis can be proven by writing out the general form of a tensor product and matching coefficients. The classic examples of maximally entangled states are the Bell states:\n\\[\n|\\Phi^+\\rangle = \\frac{|00\\rangle + |11\\rangle}{\\sqrt{2}} \\qquad |\\Phi^-\\rangle = \\frac{|00\\rangle - |11\\rangle}{\\sqrt{2}}\n\\] \\[\n|\\Psi^+\\rangle = \\frac{|01\\rangle + |10\\rangle}{\\sqrt{2}} \\qquad |\\Psi^-\\rangle = \\frac{|01\\rangle - |10\\rangle}{\\sqrt{2}}\n\\]\nFor mixed states, the situation is more complex and requires measures like concurrence to fully characterize entanglement.\n\n\n\n\n\n\nExample: Separable state condition\n\n\n\nConsider a separable two-qubit state formed by the tensor product of two arbitrary single-qubit states:\n\\[\n|\\phi_1\\rangle = a|0\\rangle + b|1\\rangle \\qquad |\\phi_2\\rangle = c|0\\rangle + d|1\\rangle\n\\]\nTheir tensor product gives:\n\\[\n\\begin{aligned}\n|\\phi_1\\rangle \\otimes |\\phi_2\\rangle &= (a|0\\rangle + b|1\\rangle) \\otimes (c|0\\rangle + d|1\\rangle) \\\\\n&= ac|00\\rangle + ad|01\\rangle + bc|10\\rangle + bd|11\\rangle\n\\end{aligned}\n\\]\nThe coefficient matrix determinant is: \\[\n\\begin{vmatrix}\nac & ad \\\\\nbc & bd\n\\end{vmatrix} = (ac)(bd) - (ad)(bc) = abcd - abcd = 0\n\\]\nThis confirms that any separable state satisfies the zero determinant condition. Conversely, if a state’s coefficient matrix has non-zero determinant, it must be entangled.\n\n\n\n\n\n\n\n\nExample: Checking for Entanglement\n\n\n\nLet’s examine two states to see if they’re entangled:\n\nConsider the state \\(|\\psi_1\\rangle = \\frac{1}{\\sqrt{2}}(|00\\rangle + |11\\rangle)\\) The coefficient matrix is: \\[\n\\begin{pmatrix}\n1/\\sqrt{2} & 0 \\\\\n0 & 1/\\sqrt{2}\n\\end{pmatrix}\n\\] The determinant is \\((1/\\sqrt{2})(1/\\sqrt{2}) - (0)(0) = 1/2 \\neq 0\\), so this state is entangled.\nConsider the state \\(|\\psi_2\\rangle = \\frac{1}{\\sqrt{2}}(|00\\rangle + |01\\rangle)\\) The coefficient matrix is: \\[\n\\begin{pmatrix}\n1/\\sqrt{2} & 1/\\sqrt{2} \\\\\n0 & 0\n\\end{pmatrix}\n\\] The determinant is \\((1/\\sqrt{2})(0) - (1/\\sqrt{2})(0) = 0\\), so this state is separable. Indeed, we can write it as \\(|\\psi_2\\rangle = |0\\rangle \\otimes \\frac{1}{\\sqrt{2}}(|0\\rangle + |1\\rangle)\\).\nConsider the state \\(|\\psi_3\\rangle = \\frac{1}{2}(|00\\rangle + |01\\rangle + |10\\rangle + |11\\rangle)\\) The coefficient matrix is: \\[\n\\begin{pmatrix}\n1/2 & 1/2 \\\\\n1/2 & 1/2\n\\end{pmatrix}\n\\] The determinant is \\((1/2)(1/2) - (1/2)(1/2) = 0\\), so this state is separable. We can verify this by rewriting it as: \\(|\\psi_3\\rangle = \\frac{1}{\\sqrt{2}}(|0\\rangle + |1\\rangle) \\otimes \\frac{1}{\\sqrt{2}}(|0\\rangle + |1\\rangle)\\)\n\n\n\n\n\n3.2.3 Reduced density matrices\nFor entangled states, we often want to describe the state of a single qubit within the two-qubit system. This is done using the reduced density matrix, obtained by “tracing out” the other qubit. The process, called the partial trace, gives us a density matrix that describes all measurable properties of the subsystem we’re interested in.\nFor a two-qubit system in state \\(|\\psi\\rangle\\), the density matrix is \\(\\rho = |\\psi\\rangle\\langle\\psi|\\). To get the reduced density matrix for the first qubit (\\(\\rho_A\\)), we take the partial trace over the second qubit (B):\n\\[\n\\rho_A = \\text{Tr}_B(\\rho) = \\sum_{b=0}^1 \\langle b_B|\\rho|b_B\\rangle\n\\]\nFor a single term \\(\\langle b_B|\\rho|b_B\\rangle\\), this gives a \\(2\\times2\\) matrix acting on the first qubit:\n\\[\n\\begin{aligned}\n\\langle b_B|\\rho|b_B\\rangle & = \\begin{pmatrix}\n\\langle 0 b|\\rho|0 b\\rangle & \\langle 0 b|\\rho|1 b\\rangle \\\\\n\\langle 1 b|\\rho|0 b\\rangle & \\langle 1 b|\\rho|1 b\\rangle\n\\end{pmatrix} \\\\\n& = \\begin{pmatrix}\n|\\braket{0 b | \\psi}|^2 & \\braket{0 b |\\psi} \\braket{1b| \\psi}^* \\\\\n\\braket{1b|\\psi}\\braket{0b|\\psi}^* & |\\braket{1b|\\psi}|^2\n\\end{pmatrix}\n\\end{aligned}\n\\]\nwhere \\(|b_B\\rangle\\) are the basis states of qubit B. Each element of \\(\\rho_A\\) is a sum of two elements from the original density matrix, corresponding to tracing out qubit B in the computational basis.\n\n\n\n\n\n\nTensor notation for density matrices\n\n\n\nIn tensor notation, a two-qubit state \\(|\\psi\\rangle\\) has components \\(\\psi_{ij}\\) where \\(i,j\\) label the basis states of the first and second qubit. The density matrix elements are then \\(\\rho_{ij,kl} = \\psi_{ij}\\psi_{kl}^*\\), where the first pair of indices \\((i,j)\\) corresponds to the ket and \\((k,l)\\) to the bra.\nThe partial trace over qubit B corresponds to summing over matching indices for qubit B:\n\\[\n(\\rho_A)_{ik} = \\sum_j \\rho_{ij,kj}\n\\] This tensor notation makes it clear why this operation is called a “trace” - we’re summing over diagonal elements where the indices for system B match (j=j), just like in the usual matrix trace, while keeping the indices for system A (i,k) free.\n\n\n\n\n\n\n\n\nExample: Reduced density matrix of a Bell state\n\n\n\nConsider the Bell state \\(|\\Phi^+\\rangle = \\frac{|00\\rangle + |11\\rangle}{\\sqrt{2}}\\). Its density matrix is:\n\\[\n\\rho = |\\Phi^+\\rangle\\langle\\Phi^+| = \\frac{1}{2}(|00\\rangle\\langle00| + |00\\rangle\\langle11| + |11\\rangle\\langle00| + |11\\rangle\\langle11|)\n\\]\nLet’s find \\(\\rho_A\\) step by step:\n\nFirst, we compute the partial trace: \\[\n\\begin{aligned}\n\\rho_A &= \\langle0_B|\\rho|0_B\\rangle + \\langle1_B|\\rho|1_B\\rangle \\\\\n&= \\frac{1}{2}|0\\rangle\\langle0| + \\frac{1}{2}|1\\rangle\\langle1| \\\\\n&= \\frac{1}{2}I\n\\end{aligned}\n\\]\nThis shows that when we look at just one qubit of a maximally entangled pair:\n\nIt appears to be in a completely mixed state\nWe have equal probability of measuring 0 or 1\nAll quantum information is stored in the correlations between qubits\n\n\n\n\nThe reduced density matrix reveals a key feature of entanglement: while the total state is pure (\\(\\rho^2 = \\rho\\)), the subsystem state can be mixed (\\(\\rho_A^2 \\neq \\rho_A\\)). This is a signature of entanglement - if we can only access one qubit of an entangled pair, we see a statistical mixture rather than a pure state.\n\n\n\n\n\n\nExample: Partial Trace for a General Two-Qubit State\n\n\n\nSuppose we have a general two-qubit pure state: \\[\n|\\psi\\rangle = \\alpha|00\\rangle + \\beta|01\\rangle + \\gamma|10\\rangle + \\delta|11\\rangle.\n\\] The full density matrix is: \\[\n\\rho = |\\psi\\rangle \\langle \\psi|\n= \\begin{pmatrix}\n\\alpha \\\\ \\beta \\\\ \\gamma \\\\ \\delta\n\\end{pmatrix}\n\\begin{pmatrix}\n\\alpha^* & \\beta^* & \\gamma^* & \\delta^*\n\\end{pmatrix}.\n\\]\nTo find the reduced density matrix of the first qubit, \\(\\rho_A = \\mathrm{Tr}_B(\\rho)\\), group the basis states so that qubit B’s index is traced out:\n\\[\n\\rho_A =\n\\begin{pmatrix}\n|\\alpha|^2 + |\\beta|^2 & \\alpha\\gamma^*+\\beta\\delta^* \\\\\n\\gamma\\alpha^* + \\delta\\beta^* & |\\gamma|^2 + |\\delta|^2\n\\end{pmatrix}.\n\\]\nThis \\(2\\times2\\) matrix captures all local measurements and observables on qubit A, regardless of the state of qubit B.\n\n\n\n\n\n\n\n\nWhy Care About Reduced Density Matrices?\n\n\n\nReduced density matrices are crucial because they tell us what we can observe when we only have access to part of an entangled system. They help answer questions like:\n\nLocal Measurements: What results will we get if we only measure one qubit of an entangled pair?\nQuantum Information: How much information is accessible locally vs. stored in correlations?\nDecoherence: How does interaction with the environment affect our quantum system?\n\nFor example, in quantum teleportation, while the total state remains pure, the reduced density matrix of the transmitted qubit appears completely mixed until the classical information is received. This explains why teleportation cannot transmit information faster than light!\n\n\n\n\n3.2.4 Quantifying entanglement\nSeveral measures exist to quantify entanglement, each capturing different aspects:\n\nVon Neumann entropy: For a pure bipartite state \\(|\\psi\\rangle\\), the entanglement entropy is \\(S(\\rho_A) = -\\text{Tr}(\\rho_A \\log_2 \\rho_A)\\) where \\(\\rho_A\\) is the reduced density matrix of subsystem A. For two qubits, this ranges from 0 for separable states to 1 for maximally entangled states.\nConcurrence  [9]: For a two-qubit state \\(\\rho\\), defined as \\(C(\\rho) = \\max(0, \\lambda_1 - \\lambda_2 - \\lambda_3 - \\lambda_4)\\) where \\(\\lambda_i\\) are the square roots of eigenvalues of \\(\\rho(Y \\otimes Y)\\rho^*(Y \\otimes Y)\\) in decreasing order (this reduces to \\(2|\\alpha\\delta - \\beta\\gamma|\\) for a pure state \\(|\\psi\\rangle = \\alpha|00\\rangle + \\beta|01\\rangle + \\gamma|10\\rangle + \\delta|11\\rangle\\)).\nNegativity: Based on the partial transpose of the density matrix, providing a computable measure that captures the degree of entanglement. However, while negativity is zero for separable states, a zero negativity does not guarantee separability for some higher-dimensional systems - there exist entangled states with zero negativity.\n\nThese measures help quantify the “quantum-ness” of correlations and their potential utility in quantum information protocols. All of these are discussed in detail in  [8].\nWe will find that many protocols of usefulness will produce entanglement in the system, though often only when in a particular basis. We will see that in the next section when we introduce operators on this Hilbert space\n\n\n\n\n\n\nEntanglement depends on the partition\n\n\n\nWhen we talk about entanglement between subsystems A and B, it’s crucial to understand that this depends entirely on how we choose to divide our total system into these subsystems. The same quantum state can appear entangled or unentangled depending on this choice of partition.\nFor example, consider the state: \\[\n|\\psi\\rangle = \\frac{1}{\\sqrt{2}}(|00\\rangle + |11\\rangle),\n\\]\nthis is clearly an entangled Bell state, but our Hilbert space exists as (complex) four-dimensional space. I could “relabel” my states into a new basis (which we can define with a tilde), such that \\[\n\\begin{aligned}\n\\ket{00} & = \\frac1{\\sqrt{2}}( \\ket{\\tilde 0 \\tilde 0} + \\ket{\\tilde 1 \\tilde 1}), \\\\\n\\ket{11} & = \\frac1{\\sqrt{2}}( \\ket{\\tilde 0 \\tilde 0} - \\ket{\\tilde 1 \\tilde 1}), \\\\\n\\ket{01} & = \\frac1{\\sqrt{2}}( \\ket{\\tilde 0 \\tilde 1} + \\ket{\\tilde 1 \\tilde 0}), \\\\\n\\ket{10} & = \\frac1{\\sqrt{2}}( \\ket{\\tilde 0 \\tilde 1} - \\ket{\\tilde 1 \\tilde 0}), \\\\\n\\end{aligned}\n\\] and if we do that, we see that\n\\[\n\\ket\\psi = \\ket{\\tilde 0 \\tilde 0},\n\\]\na completely disentangled state! This is not to say that \\(\\ket{\\psi}\\) is not entangled, it is. It is merely important to remember that entanglement is defined with respect to a certain partitioning of your Hilbert space. The space represented by \\(\\tilde 0\\) and \\(\\tilde 1\\) is a complex combination of 00, 01, 10, and 11.\nIt is usually the physical situation which dictates how we partition our system (systems that are physically isolated from each other or for which we have single degrees of freedom which admit simple tensor products when considered with other systems).\n\n\n\n\n\n\n\n\nWhen to Use Different Entanglement Measures\n\n\n\nEach entanglement measure has its strengths:\n\nVon Neumann Entropy\n\nBest for: Pure bipartite states\nAdvantages: Clear physical interpretation, easy to calculate\nUse when: You want to quantify how much quantum information is shared between subsystems\n\nConcurrence\n\nBest for: Two-qubit mixed states\nAdvantages: Can be directly calculated from density matrix\nUse when: Working with noisy or mixed two-qubit states\n\nNegativity\n\nBest for: Higher-dimensional systems\nAdvantages: Easy to compute, works for mixed states\nUse when: Dealing with larger systems or when you need a quick estimate of entanglement\n\n\nExample: For the Bell state \\(\\ket{\\Phi^+} = \\frac{1}{\\sqrt{2}}(\\ket{00} + \\ket{11})\\):\n\nVon Neumann Entropy = 1 (maximally entangled)\nConcurrence = 1 (maximally entangled)\nNegativity = 0.5 (maximum value for two qubits)\n\n\n\n\n\n\n\n\n\nThree qubits can be entangled in two inequivalent ways  [10]\n\n\n\nThree-qubit entanglement introduces fundamentally new features not present in two-qubit systems. The most famous example is the GHZ state (named after Greenberger, Horne, and Zeilinger  [11]):\n\\[\n|\\text{GHZ}\\rangle = \\frac{1}{\\sqrt{2}}(|000\\rangle + |111\\rangle)\n\\]\nUnlike two-qubit entanglement, which has only one type of maximal entanglement (equivalent to Bell states), three-qubit systems can exhibit qualitatively different kinds of entanglement. The GHZ state above has the special property that measuring any one qubit immediately determines the state of the other two, but if you lose (trace out) any one qubit, the remaining two qubits are completely unentangled. This is fundamentally different from another type of three-qubit entanglement called the W state:\n\\[\n|W\\rangle = \\frac{1}{\\sqrt{3}}(|001\\rangle + |010\\rangle + |100\\rangle)\n\\]\nwhich maintains some two-qubit entanglement even after losing one qubit. These distinct classes of entanglement cannot be converted into each other using local operations and classical communication (LOCC).",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Multiple Qubits</span>"
    ]
  },
  {
    "objectID": "multiple_qubits.html#multi-qubit-operations",
    "href": "multiple_qubits.html#multi-qubit-operations",
    "title": "3  Multiple Qubits",
    "section": "3.3 Multi-qubit operations",
    "text": "3.3 Multi-qubit operations\nWith our exponentially big state space created and entanglement characterized, we can begin to think about how to translate our single qubit operations to multiple qubits and then how to build up operations that use multiple qubits. We will focus on two qubit gates since these will help us build up a set of universal gates for quantum computation.\n\n3.3.1 Single-qubit gates\nWhen we want to apply a single-qubit gate to one qubit in a multi-qubit system, we need to use tensor products to construct the appropriate operator. For a two-qubit system, if we want to apply a gate \\(U\\) to the first qubit, the full operator is:\n\\[\nU \\otimes I\n\\]\nwhere \\(I\\) is the \\(2\\times 2\\) identity matrix. Similarly, to apply \\(U\\) to the second qubit, we use:\n\\[\nI \\otimes U\n\\]\nFor example, applying the Pauli-X gate to the first qubit of a two-qubit system gives:\n\\[\nX \\otimes I = \\begin{pmatrix} 0 & 1 \\\\ 1 & 0 \\end{pmatrix} \\otimes \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix} = \\begin{pmatrix} 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 1 \\\\ 1 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 \\end{pmatrix}\n\\]\nwhere the rows and columns correspond to the basis states in order \\(|00\\rangle\\), \\(|01\\rangle\\), \\(|10\\rangle\\), \\(|11\\rangle\\). For example, the 1 in the third row, first column means \\(X \\otimes I\\) transforms \\(|00\\rangle\\) to \\(|10\\rangle\\), which flips the first qubit as expected.\nSimilarly, applying it to the second qubit gives:\n\\[\nI \\otimes X = \\begin{pmatrix} 1 & 0 \\\\ 0 & 1 \\end{pmatrix} \\otimes \\begin{pmatrix} 0 & 1 \\\\ 1 & 0 \\end{pmatrix} = \\begin{pmatrix} 0 & 1 & 0 & 0 \\\\ 1 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 1 \\\\ 0 & 0 & 1 & 0 \\end{pmatrix}\n\\]\nHere, the 1 in the second row, first column shows \\(I \\otimes X\\) transforms \\(|00\\rangle\\) to \\(|01\\rangle\\), flipping only the second qubit as expected.\nThis pattern extends to more qubits. For an \\(N\\)-qubit system, to apply \\(U\\) to the \\(k\\)th qubit, we use:\n\\[\n\\underbrace{I \\otimes \\cdots \\otimes I}_{k-1} \\otimes U \\otimes \\underbrace{I \\otimes \\cdots \\otimes I}_{N-k}\n\\]\nwhere \\(U\\) appears in the \\(k\\)th position and \\(I\\) appears in all other positions. This construction ensures we affect only the target qubit while leaving all other qubits unchanged.\n\n\n\n\n\n\nExample: H gate on second qubit of three-qubit system\n\n\n\nLet’s see how applying \\(H\\) to the second qubit of a three-qubit system works. The operator is:\n\\[\nI \\otimes H \\otimes I\n\\]\nActing on the state \\(|000\\rangle\\):\n\\[\n\\begin{aligned}\n(I \\otimes H \\otimes I)|000\\rangle &= (I \\otimes H \\otimes I)(|0\\rangle \\otimes |0\\rangle \\otimes |0\\rangle) \\\\\n&= (I|0\\rangle) \\otimes (H|0\\rangle) \\otimes (I|0\\rangle) \\\\\n&= |0\\rangle \\otimes \\frac{|0\\rangle + |1\\rangle}{\\sqrt{2}} \\otimes |0\\rangle \\\\\n&= \\frac{|000\\rangle + |010\\rangle}{\\sqrt{2}}\n\\end{aligned}\n\\]\nAs expected, only the middle qubit is put into an equal superposition of 0 and 1.\n\n\n\n\n\n\n\n\nNotational convenience for single-qubit operations\n\n\n\nTo avoid writing long chains of tensor products, we often use a subscript to indicate which qubit an operator acts on. For example, instead of writing\n\\[\nI \\otimes X \\otimes I \\otimes I \\otimes X\n\\]\nfor a five-qubit system where we apply \\(X\\) to qubits 2 and 5, we can write this more compactly as\n\\[\nX_2 X_5\n\\]\nSimilarly, applying the Hadamard gate to the third qubit of a four-qubit system would be written as\n\\[\nH_3\n\\]\nrather than \\(I \\otimes I \\otimes H \\otimes I\\). This notation is particularly helpful when describing quantum circuits involving many qubits.\n\n\n\n\n3.3.2 Two-qubit gates\nTo begin to build up a full set of logical gates, we start with “controlled” gates. These are gates that will act as single qubit gates on one qubit (the target), but only if another qubit (the control) is in the \\(\\ket{1}\\) state.\nWe first introduce the two-qubit gate called the controlled-NOT (CNOT) gate, which flips the second qubit (target) when the first qubit (control) is in state \\(|1\\rangle\\)2.\nThe CNOT gate can be written as a \\(4 \\times 4\\) matrix acting on the two-qubit basis states \\(|00\\rangle\\), \\(|01\\rangle\\), \\(|10\\rangle\\), and \\(|11\\rangle\\):\n\\[\n\\text{CNOT} = \\begin{pmatrix}\n1 & 0 & 0 & 0 \\\\\n0 & 1 & 0 & 0 \\\\\n0 & 0 & 0 & 1 \\\\\n0 & 0 & 1 & 0\n\\end{pmatrix}\n\\]\nWe can understand this matrix by seeing how it acts on each basis state:\n\\[\n\\begin{aligned}\n\\text{CNOT}|00\\rangle &= |00\\rangle \\\\\n\\text{CNOT}|01\\rangle &= |01\\rangle \\\\\n\\text{CNOT}|10\\rangle &= |11\\rangle \\\\\n\\text{CNOT}|11\\rangle &= |10\\rangle\n\\end{aligned}\n\\]\nWhen the first (control) qubit is \\(|0\\rangle\\), the target qubit is unchanged. When the control qubit is \\(|1\\rangle\\), the target qubit is flipped (X gate applied). This has a circuit representation which we show below in Fig. 3.1.\n\n\n\n\n\n\n\n\n\n\n\n\n(a) CNOT gate with control in \\(|0\\rangle\\)\n\n\n\n\n\n\n\n\n\n\n\n(b) CNOT gate with control in \\(|1\\rangle\\)\n\n\n\n\n\n\n\nFig. 3.1: The CNOT gate behavior depends on the control qubit state. When the control is \\(|0\\rangle\\) (left), the target is unchanged. When the control is \\(|1\\rangle\\) (right), the target is flipped.\n\n\n\nThe CNOT gate’s action on computational basis states appears simple - it either leaves them unchanged (when control is |0⟩) or flips the target (when control is |1⟩). However, when applied to superposition states, the CNOT can create entanglement.\nFor example, consider applying CNOT to a superposition state created by applying a Hadamard gate to the first qubit (circuit diagram in Fig. 3.2).\n\n\n\n\n\n\n\nFig. 3.2: The application of \\(H\\) followed by a CNOT gate can create the Bell state \\(\\frac1{\\sqrt2}(\\ket{00}+\\ket{11})\\).\n\n\n\nWe can verify this mathematically: \\[\n\\begin{aligned}\n|00\\rangle &\\xrightarrow{H \\otimes I} \\frac{|0\\rangle + |1\\rangle}{\\sqrt{2}} \\otimes |0\\rangle = \\frac{|00\\rangle + |10\\rangle}{\\sqrt{2}} \\\\\n&\\xrightarrow{\\text{CNOT}} \\frac{|00\\rangle + |11\\rangle}{\\sqrt{2}}\n\\end{aligned}\n\\]\nThe resulting state is the Bell state \\(|\\Phi^+\\rangle\\) which we saw earlier - a maximally entangled state that cannot be written as a product of individual qubit states.\nThe CNOT gate is just one example of a controlled operation. More generally, we can create controlled versions of any single-qubit gate, where the target operation is applied only when the control qubit is \\(\\ket{1}\\). The most common controlled gates are:\n\nControlled-X (CNOT): Flips the target qubit if control is \\(\\ket{1}\\), Fig. 3.3 (a)\nControlled-Z (CZ): Adds -1 phase if both qubits are \\(\\ket{1}\\), Fig. 3.3 (c)\nControlled-Y (CY): Applies Y rotation if control is \\(\\ket{1}\\), Fig. 3.3 (b)\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a) CX\n\n\n\n\n\n\n\n\n\n\n\n(b) CY\n\n\n\n\n\n\n\n\n\n\n\n(c) CZ\n\n\n\n\n\n\n\nFig. 3.3: Circuit Notation for controlled-X (CX), controlled-Y (CY), and controlled-Z (CZ) gates. Note that CX=CNOT, so this is just an alternative circuit notation.\n\n\n\nAny controlled gate can be constructed using CNOT gates and single-qubit operations. For example, the CZ gate can be implemented as:\n\n\n\n\n\n\n\nFig. 3.4: The CZ gate can be decomposed into two Hadamards sandwiching a CNOT (CX) gate.\n\n\n\nThis notation is flexible as well, we can begin to apply any unitary matrix \\(U\\) onto a target qubit and have a control qubit for it. This generically will look like\n\n\n\n\n\n\n\nFig. 3.5: An arbitrary controlled gate\n\n\n\nMathematically, we can write this out in a four-by-four matrix \\[\n\\text{CU} = \\begin{pmatrix}\n1 & 0 & 0 & 0 \\\\\n0 & 1 & 0 & 0 \\\\\n0 & 0 & U_{11} & U_{12} \\\\\n0 & 0 & U_{21} & U_{22}\n\\end{pmatrix}\n\\]\nwhere \\(U_{ij}\\) are the matrix elements of the single-qubit unitary \\(U = \\begin{pmatrix} U_{11} & U_{12} \\\\ U_{21} & U_{22} \\end{pmatrix}\\).\nAnother important two-qubit gate is the SWAP gate, which exchanges the states of two qubits. The SWAP gate can be written as a four-by-four matrix:\n\\[\n\\text{SWAP} = \\begin{pmatrix}\n1 & 0 & 0 & 0 \\\\\n0 & 0 & 1 & 0 \\\\\n0 & 1 & 0 & 0 \\\\\n0 & 0 & 0 & 1\n\\end{pmatrix}\n\\]\nUnlike controlled gates, the SWAP gate cannot create entanglement - it simply swaps the quantum states between the qubits. The circuit notation for a SWAP gate is:\n\n\n\n\n\n\n\nFig. 3.6: SWAP gate circuit notation\n\n\n\nWe’ve seen how this can already create entanglement even though one qubit is merely acting as “control,” and how we can “SWAP” two qubits. However, we can also write down more general four-by-four matrices on two qubits and if we have a generic four-by-four matrix \\(U_4\\), we will write that circuit element as\n\n\n\n\n\n\n\nFig. 3.7: A generic unitary on two qubits can be represented by a block spanning the two qubits\n\n\n\nThese two-qubit gates form the foundation for quantum computation with multiple qubits. The controlled operations, particularly the CNOT gate, are essential building blocks for quantum algorithms, while general two-qubit unitaries give us the full power to manipulate quantum states in ways impossible with just single-qubit operations. Understanding how these gates create and manipulate entanglement is crucial.\n\n\n\n\n\n\nExample: Creating different entangled states\n\n\n\nLet’s see how different combinations of gates create distinct entangled states:\n\nBell state \\(\\ket{\\Phi^+}\\):\n|0⟩ --H--•--|\n         |\n|0⟩ -----X--|\n\\(\\ket{00} \\xrightarrow{H \\otimes I} \\frac{\\ket{00} + \\ket{10}}{\\sqrt{2}} \\xrightarrow{CNOT} \\frac{\\ket{00} + \\ket{11}}{\\sqrt{2}}\\)\nBell state \\(\\ket{\\Psi^+}\\):\n|0⟩ --H--•--|\n         |\n|0⟩ --X--X--|\n\\(\\ket{00} \\xrightarrow{I \\otimes X} \\ket{01} \\xrightarrow{H \\otimes I} \\frac{\\ket{01} + \\ket{11}}{\\sqrt{2}} \\xrightarrow{CNOT} \\frac{\\ket{01} + \\ket{10}}{\\sqrt{2}}\\)\n\nThis shows how different gate sequences can create different types of entanglement. Note: We have used the fixed-width font notation for circuit diagrams here.\n\n\n\n3.3.2.1 Universal gate sets\nJust as classical computation can be performed using a small set of universal gates (like NAND or NOR), quantum computation can be achieved using a finite set of quantum gates that can approximate any unitary operation to arbitrary precision. This is known as a universal gate set.\nA common universal gate set consists of:\n\nThe CNOT gate\nSingle-qubit rotations (or equivalently, any set of gates that can approximate any single-qubit rotation)\n\nRemarkably, these are sufficient to construct any unitary operation on any number of qubits, though the construction may require many gates. This is analogous to how NAND gates can be used to build any classical logic circuit.\nThere are several alternative universal gate sets. Some common ones include:\n\nCZ (or CY) + single-qubit rotations\nCNOT + Hadamard + Phase (S) gate + T gate\nToffoli + Hadamard\n\nThe choice of which universal gate set to use often depends on the physical implementation of the quantum computer. For example, some quantum computing architectures might naturally implement CZ gates rather than CNOT gates, making the CZ-based universal set more practical.\nIt’s worth noting that while we can approximate any unitary to arbitrary precision with these gate sets, the number of gates required might grow exponentially with the desired precision. This is known as the Solovay-Kitaev theorem, which provides an algorithm for finding such approximations.\n\n\n\n\n\n\nExample: Creating a GHZ State\n\n\n\nA three-qubit GHZ state is \\[\n| \\text{GHZ} \\rangle = \\frac{|000\\rangle + |111\\rangle}{\\sqrt{2}}.\n\\]\nWe can create this state using the following sequence of gates:\n\nStart from \\(|000\\rangle\\)\nApply a Hadamard gate to the first qubit: \\[\n|000\\rangle \\xrightarrow{H \\otimes I \\otimes I} \\frac{|000\\rangle + |100\\rangle}{\\sqrt{2}}\n\\]\nApply two consecutive CNOTs, using the first qubit as the control: \\[\n\\begin{aligned}\n&\\frac{|000\\rangle + |100\\rangle}{\\sqrt{2}}\n\\xrightarrow{\\text{CNOT on qubits 1→2}}\n\\frac{|000\\rangle + |110\\rangle}{\\sqrt{2}} \\\\\n&\\quad \\xrightarrow{\\text{CNOT on qubits 1→3}}\n\\frac{|000\\rangle + |111\\rangle}{\\sqrt{2}}\n\\end{aligned}\n\\]\n\nMeasuring any qubit in the computational basis will instantly project the entire system into either \\(|000\\rangle\\) or \\(|111\\rangle\\), illustrating the strong correlations present in multipartite entanglement.\n\n\n\n\n\n3.3.3 Measurement\nWhen measuring multiple qubits, we need to extend our understanding of single-qubit measurements. For a single qubit, measuring in the computational basis was straightforward - we would get either \\(\\ket{0}\\) or \\(\\ket{1}\\). However, in a multi-qubit system, measuring just one qubit introduces an important concept: partial measurements and degeneracy.\nConsider measuring the first qubit of a two-qubit state in the computational basis. The measurement operators are:\n\\[\nP_0 = |0\\rangle\\langle 0| \\otimes I = \\begin{pmatrix} 1 & 0 & 0 & 0 \\\\ 0 & 1 & 0 & 0 \\\\ 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 \\end{pmatrix}\n\\]\n\\[\nP_1 = |1\\rangle\\langle 1| \\otimes I = \\begin{pmatrix} 0 & 0 & 0 & 0 \\\\ 0 & 0 & 0 & 0 \\\\ 0 & 0 & 1 & 0 \\\\ 0 & 0 & 0 & 1 \\end{pmatrix}\n\\]\nThese operators are degenerate - for example, \\(P_0\\) projects onto both \\(|00\\rangle\\) and \\(|01\\rangle\\) states. This means when we measure the first qubit and get 0, the second qubit remains in a quantum state.\n\n\n\n\n\n\nExample: Partial Measurement\n\n\n\nConsider the state: \\[\n|\\psi\\rangle = \\frac{1}{2}(|00\\rangle + |01\\rangle + |10\\rangle + |11\\rangle)\n\\]\nIf we measure the first qubit and get 0, the state collapses to: \\[\n|\\psi'\\rangle = \\frac{1}{\\sqrt{2}}(|00\\rangle + |01\\rangle)\n\\]\nThe second qubit remains in a superposition!\n\n\nWhen measuring multiple qubits, we need to be careful about how we calculate probabilities. For a single qubit, the probability of measuring \\(\\ket{0}\\) was simply \\(\\lvert\\braket{0|\\psi}\\rvert^2\\). However, with multiple qubits, we need to sum over all possible configurations of the unmeasured qubits.\nFor example, if we have a two-qubit state \\(|\\psi\\rangle\\) and measure only the first qubit, the probability of getting 0 is:\n\\[\np(0) = \\sum_i |\\langle 0i|\\psi\\rangle|^2\n\\]\nwhere \\(i\\) runs over all possible states of the second qubit (0 and 1). This sum accounts for all ways we could get outcome 0 on the first qubit, regardless of what state the second qubit is in.\n\n\n\n\n\n\nExample: Calculating Measurement Probabilities\n\n\n\nConsider again the state: \\[\n|\\psi\\rangle = \\frac{1}{2}(|00\\rangle + |01\\rangle + |10\\rangle + |11\\rangle)\n\\]\nThe probability of measuring 0 on the first qubit is: \\[\n\\begin{aligned}\np(0) &= |\\langle 00|\\psi\\rangle|^2 + |\\langle 01|\\psi\\rangle|^2 \\\\\n&= \\left|\\frac{1}{2}\\right|^2 + \\left|\\frac{1}{2}\\right|^2 \\\\\n&= \\frac{1}{2}\n\\end{aligned}\n\\]\nThis matches our intuition - the first qubit is equally likely to be 0 or 1.\n\n\n\n3.3.3.1 Measuring General Observables\nIn practice, we may be restricted in what we can measure on a quantum computer, such as only in the computational (\\(Z\\)) basis. However, we often need to measure other observables. For example, we might want to measure the parity of two qubits (\\(Z_1Z_2\\)) or their correlation (\\(X_1X_2\\)).\nTo measure these observables, we need to transform our state before measurement. This is done by applying appropriate unitary operations that map our desired measurement basis to the computational basis.\nFor example, as we saw in the single qubit section, to measure in the X basis, we first apply \\(H\\) before measuring in the computational basis.\nFor two-qubit observables like \\(Z_1 Z_2\\), we can use controlled operations to map the eigenspaces to computational basis states. Here’s how we might measure \\(Z_1 Z_2\\).\nFirst, let’s write out how \\(Z_1 Z_2\\) acts on the computational basis, separting out the +1 eigenvalues from the -1 eigenvalues\n\n\n\nState\n\\(Z_1Z_2\\)\n\\(Z_2\\)\n\n\n\n\n\\(\\ket{00}\\)\n\\(+1\\)\n\\(+1\\)\n\n\n\\(\\ket{01}\\)\n\\(-1\\)\n\\(-1\\)\n\n\n\\(\\ket{10}\\)\n\\(-1\\)\n\\(+1\\)\n\n\n\\(\\ket{11}\\)\n\\(+1\\)\n\\(-1\\)\n\n\n\nNotice that these operators have the same number of +1 and -1 eigenvalues. On top of that, the states \\(\\ket{00}\\) and \\(\\ket{01}\\) have the same eigenvalue, and \\(\\ket{10}\\) and \\(\\ket{11}\\) flips. This sounds like a CNOT gate, in fact if we have a unitary that takes \\(\\ket{10} \\mapsto \\ket{11}\\) and \\(\\ket{11} \\mapsto \\ket{10}\\), while leaving \\(\\ket{00}\\) and \\(\\ket{01}\\) alone, these operators match.\nLet’s build out a way to relate these operators which we will then use to measure any string Pauli matrices. With the above, we note that \\[\n\\begin{aligned}\n\\ket{00} & \\mapsto \\ket{00},\\\\\n\\ket{01} & \\mapsto \\ket{01}, \\\\\n\\ket{10} & \\mapsto \\ket{11}, \\\\\n\\ket{11} & \\mapsto \\ket{10}\n\\end{aligned}\n\\] will let us map \\(Z_1 Z_2 \\mapsto Z_2\\). This has a simple matrix form \\[\n\\begin{pmatrix}\n1 & 0 & 0 & 0 \\\\\n0 & 1 & 0 & 0 \\\\\n0 & 0 & 0 & 1 \\\\\n0 & 0 & 1 & 0\n\\end{pmatrix}.\n\\] In other words, the CNOT gate. Formally, this means that \\[\n\\text{CNOT}\\, Z_1 Z_2\\, \\text{CNOT} = Z_2,\n\\tag{3.3}\\] which can be verified with matrix mulitplation. However, we can also note that if we apply \\(\\ket{b_1 b_2}\\) to both sides, \\[\nZ_1 Z_2 \\text{CNOT} \\ket{b_1 b_2} = \\mathrm{CNOT} (-1)^{b_2} \\ket{b_1 b_2} = (-1)^{b_2} \\mathrm{CNOT} \\ket{b_1 b_2},\n\\] which verifies that \\(\\mathrm{CNOT}\\ket{b_1 b_2}\\) is an eigenvector of \\(Z_1 Z_2\\) with eigenvalue \\((-1)^{b_2}\\) (this assume Eq. 3.3 is correct).\nTherefore, to measure \\(Z_1 Z_2\\), we perform CNOT, then measure the target qubit (number two). The circuit diagram looks like this\n\n\n\n\n\n\n\nFig. 3.8: Circuit to measure \\(Z_1Z_2\\)\n\n\n\nand if we want to not only measure \\(Z_1 Z_2\\) but ensure the system goes into an eigenstate of \\(Z_1 Z_2\\), we need to perform CNOT again\n\n\n\n\n\n\n\n\n\n\n\n\n(a) Circuit to measure \\(Z_1Z_2\\) with a single symbol\n\n\n\n\n\n\n\n\n\n\n\n(b) Circuit to measure \\(Z_1Z_2\\) with explicit gates\n\n\n\n\n\n\n\nFig. 3.9: Circuit diagrams for the \\(Z_1 Z_2\\) measurement. These two circuits are equivalent to each other.\n\n\n\nBut what about measuring other Pauli strings? We can use the fact that \\(X = H Z H\\) and \\(Y = S X S^\\dagger\\) to convert any Pauli string measurement into a \\(Z\\)-type measurement. For example, to measure \\(X_1 X_2\\), we can apply Hadamard gates to both qubits, measure \\(Z_1 Z_2\\), and then apply Hadamard gates again:\n\n\n\n\n\n\n\n\n\n\n\n\n(a) Circuit to measure \\(X_1X_2\\) with a single symbol\n\n\n\n\n\n\n\n\n\n\n\n(b) Circuit to measure \\(X_1X_2\\) with explicit gates\n\n\n\n\n\n\n\nFig. 3.10: Circuit diagrams for the \\(X_1 X_2\\) measurement. These two circuits are equivalent to each other.\n\n\n\nThis gives us a way to measure any Pauli string\n\nPerform single-particle unitaries to convert it to only \\(Z\\) and \\(I\\) operators.\nFind the permutation matrix that relates +1 and -1 eigenvalues of your \\(Z\\)-Pauli string to a single \\(Z_n\\) and apply that unitary matrix (this could be a complicated combination of CNOT gates)\nMeasure \\(Z_n\\).\nIf the correct measured state is needed, undo the unitary in #2 followed by the single-particle unitaries in #1.\n\nPauli strings are particularly “simple.” Measuring more complicated observables requires more thought and sometimes ancillary systems to assist in that measurement.\n\n\n\n\n\n\nExample: Measuring X on One Qubit of a Two-Qubit System\n\n\n\nSuppose we have a two-qubit state: \\[\n|\\phi\\rangle = \\alpha|00\\rangle + \\beta|01\\rangle + \\gamma|10\\rangle + \\delta|11\\rangle,\n\\] and we want to measure the first qubit in the \\(X\\) basis while leaving the second qubit unmeasured.\n\nRecall \\(H X H = Z\\). So to measure \\(X\\) on the first qubit, apply a Hadamard on that qubit to map the \\(X\\) basis to the \\(Z\\) basis: \\[\n(H \\otimes I)|\\phi\\rangle.\n\\]\nMeasure the first qubit in the computational basis (effectively measuring \\(Z\\) on the transformed state).\nAfter the measurement, unapply the \\(H\\) if you want to restore the original basis of the first qubit.\n\nThis procedure effectively measures \\(X_1\\) while leaving qubit 2 untouched (can it still be entangled?).\n\n\n\n\n\n\n\n\nExample: Creating entanglement through measurement\n\n\n\nLet’s see how we can create entanglement through measurement. We’ll start with the product state \\(|{+}{+}\\rangle\\) and use a \\(Z_1Z_2\\) measurement to create a maximally entangled state.\n\nInitial state: \\[\n|{+}{+}\\rangle = \\frac{1}{2}(|00\\rangle + |01\\rangle + |10\\rangle + |11\\rangle)\n\\]\nMeasuring \\(Z_1Z_2\\) projects onto the +1 or -1 eigenspaces:\n\n+1 eigenspace: span{\\(|00\\rangle\\), \\(|11\\rangle\\)}\n-1 eigenspace: span{\\(|01\\rangle\\), \\(|10\\rangle\\)}\n\nAfter measurement:\n\nIf outcome = +1: \\[\n|\\Phi^+\\rangle = \\frac{|00\\rangle + |11\\rangle}{\\sqrt{2}}\n\\]\nIf outcome = -1: \\[\n|\\Psi^+\\rangle = \\frac{|01\\rangle + |10\\rangle}{\\sqrt{2}}\n\\]\n\nIf we get -1, we can apply \\(X\\) to the second qubit to transform to \\(|\\Psi^{+}\\rangle\\): \\[\n(I \\otimes X)\\frac{|01\\rangle + |10\\rangle}{\\sqrt{2}} = \\frac{|00\\rangle + |11\\rangle}{\\sqrt{2}}\n\\]\n\nThis procedure creates the Bell state \\(|\\Phi^+\\rangle\\) regardless of measurement outcome, demonstrating how measurement plus conditional corrections can generate entanglement from separable states.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Multiple Qubits</span>"
    ]
  },
  {
    "objectID": "multiple_qubits.html#decoherence-in-multi-qubit-systems",
    "href": "multiple_qubits.html#decoherence-in-multi-qubit-systems",
    "title": "3  Multiple Qubits",
    "section": "3.4 Decoherence in multi-qubit systems",
    "text": "3.4 Decoherence in multi-qubit systems\nWhen dealing with multiple qubits, decoherence becomes even more challenging than in single-qubit systems. Not only can each qubit experience individual decoherence, but the interactions between qubits can create new pathways for errors. The main types of multi-qubit decoherence are:\n\nIndependent decoherence: Each qubit experiences its own local noise\nCorrelated decoherence: Environmental effects that simultaneously affect multiple qubits\nCross-talk: Unwanted interactions between qubits that should be isolated\n\nFor example, consider a two-qubit state that starts in a Bell state: \\[\n|\\Phi^+\\rangle = \\frac{1}{\\sqrt{2}}(|00\\rangle + |11\\rangle)\n\\] The density matrix for this pure state is: \\[\n|\\Phi^+\\rangle\\langle\\Phi^+| = \\frac{1}{2}\\begin{pmatrix}\n1 & 0 & 0 & 1 \\\\\n0 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 0 \\\\\n1 & 0 & 0 & 1\n\\end{pmatrix}\n\\]\nUnder independent dephasing, each qubit loses phase coherence separately: \\[\n\\rho(t) = \\frac{1}{2}\\begin{pmatrix}\n1 & 0 & 0 & e^{-2\\gamma t} \\\\\n0 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 0 \\\\\ne^{-2\\gamma t} & 0 & 0 & 1\n\\end{pmatrix}\n\\]\nwhich would represent exponential decay in entanglement over time; this could occur even with pure local noise. This highlights a crucial feature of quantum systems: even when noise acts independently on each qubit (i.e., local noise), it can destroy global quantum properties like entanglement. In other words, we don’t need correlated noise to degrade entanglement - local noise channels are sufficient to compromise the quantum advantages that entanglement provides.\n\n\n\n\n\n\nExample: Impact of different noise types\n\n\n\nConsider a Bell state under different noise channels:\n\nAmplitude damping on first qubit only: \\[\n\\rho(t) = \\begin{pmatrix}\n1-\\frac{e^{-\\gamma t}}{2} & 0 & 0 & \\frac{e^{-\\gamma t/2}}{\\sqrt{2}} \\\\\n0 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 0 \\\\\n\\frac{e^{-\\gamma t/2}}{\\sqrt{2}} & 0 & 0 & \\frac{e^{-\\gamma t}}{2}\n\\end{pmatrix}\n\\]\nDephasing on both qubits: \\[\n\\rho(t) = \\frac{1}{2}\\begin{pmatrix}\n1 & 0 & 0 & e^{-2\\gamma t} \\\\\n0 & 0 & 0 & 0 \\\\\n0 & 0 & 0 & 0 \\\\\ne^{-2\\gamma t} & 0 & 0 & 1\n\\end{pmatrix}\n\\]\n\nThis shows how different noise channels affect the quantum correlations in distinct ways.\n\n\n\n3.4.1 Gate Errors\nIn addition to decoherence during idle times, errors can occur during gate operations. These gate errors come in several forms:\n\nSystematic errors: Consistent over/under-rotation of gates\nRandom errors: Fluctuations in gate parameters\nCross-talk errors: Gates affecting neighboring qubits\nLeakage errors: System leaving the computational basis\n\nFor two-qubit gates like CNOT, errors are typically higher than single-qubit gates because:\n\nThey require stronger interactions between qubits\nTake longer to implement\nAre more sensitive to timing and control errors (e.g.,some qubits have to wait while single-qubit operations “catch up”).\n\n\n\n\n\n\n\nCurrent State of Gate Fidelities\n\n\n\nAs of 2021, record error rates are:\n\nSingle-qubit gates: 0.03%\nTwo-qubit gates: 0.5%\nMeasurement: 0.2%\n\nThese numbers are representative of state-of-the-art superconducting qubit platforms, as reported in  [12].\n\n\n\n\n\n\n[1] E. Schrödinger, Discussion of Probability Relations between Separated Systems, Mathematical Proceedings of the Cambridge Philosophical Society 31, 555 (1935).\n\n\n[2] A. Einstein, B. Podolsky, and N. Rosen, Can Quantum-Mechanical Description of Physical Reality Be Considered Complete?, Physical Review 47, 777 (1935).\n\n\n[3] J. S. Bell, On the Einstein Podolsky Rosen paradox, Physics Physique Fizika 1, 195 (1964).\n\n\n[4] S. J. Freedman and J. F. Clauser, Experimental Test of Local Hidden-Variable Theories, Physical Review Letters 28, 938 (1972).\n\n\n[5] A. Aspect, J. Dalibard, and G. Roger, Experimental Test of Bell’s Inequalities Using Time- Varying Analyzers, Physical Review Letters 49, 1804 (1982).\n\n\n[6] M. F. Pusey, J. Barrett, and T. Rudolph, On the reality of the quantum state, Nature Physics 8, 475 (2012).\n\n\n[7] N. D. Mermin, Bringing home the atomic world: Quantum mysteries for anybody, American Journal of Physics 49, 940 (1981).\n\n\n[8] R. Horodecki, M. Horodecki, and K. Horodecki, Quantum entanglement, Reviews of Modern Physics 81, 865 (2009).\n\n\n[9] W. Wootters, Entanglement of formation and concurrence, Quantum Information and Computation 1, 27 (2001).\n\n\n[10] W. Dür, G. Vidal, and J. I. Cirac, Three qubits can be entangled in two inequivalent ways, Physical Review A 62, 62314 (2000).\n\n\n[11] D. M. Greenberger, M. A. Horne, A. Shimony, and A. Zeilinger, Bell’s theorem without inequalities, American Journal of Physics 58, 1131 (1990).\n\n\n[12] N. P. De Leon, K. M. Itoh, D. Kim, K. K. Mehta, T. E. Northup, H. Paik, B. S. Palmer, N. Samarth, S. Sangtawesin, and D. W. Steuerman, Materials challenges and opportunities for quantum computing hardware, Science 372, eabb2823 (2021).",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Multiple Qubits</span>"
    ]
  },
  {
    "objectID": "multiple_qubits.html#footnotes",
    "href": "multiple_qubits.html#footnotes",
    "title": "3  Multiple Qubits",
    "section": "",
    "text": "This is true for pure states, but can be easily generalized to mixed states, see  [8].↩︎\nThis is also known as the CX-gate (the controlled-\\(X\\) gate).↩︎",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>Multiple Qubits</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "[1] F.\nArute et al., Quantum supremacy using\na programmable superconducting processor, Nature\n574, 505 (2019).\n\n\n[2] Google Quantum AI and Collaborators et al., Quantum error\ncorrection below the surface code threshold, Nature (2024).\n\n\n[3] E.\nPednault, J. A. Gunnels, G. Nannicini, L. Horesh, and R. Wisnieff, Leveraging\nSecondary Storage to Simulate Deep 54-qubit\nSycamore Circuits, arXiv:1910.09534 (2019).\n\n\n[4] F.\nPan, K. Chen, and P. Zhang, Solving the\nSampling Problem of the Sycamore Quantum\nCircuits, Physical Review Letters 129,\n090502 (2022).\n\n\n[5] M.\nA. Nielsen and I. L. Chuang, Quantum Computation and\nQuantum Information: 10th Anniversary\nEdition, Anniversary edition (Cambridge University Press,\nCambridge ; New York, 2011).\n\n\n[6] A.\nM. Turing, On\nComputable Numbers, with an Application to the\nEntscheidungsproblem, Proceedings of the London\nMathematical Society s2-42, 230 (1937).\n\n\n[7] L.\nHoddeson, The\nDiscovery of the Point-Contact Transistor,\nHistorical Studies in the Physical Sciences 12, 41\n(1981).\n\n\n[8] S.\nBravyi and A. Kitaev, Universal quantum\ncomputation with ideal Clifford gates and noisy\nancillas, Physical Review A 71, 022316\n(2005).\n\n\n[9] R.\nP. Feynman, Simulating\nphysics with computers, International Journal of Theoretical Physics\n21, 467 (1982).\n\n\n[10] D.\nDeutsch, Quantum\ntheory, the Church–Turing principle and the\nuniversal quantum computer, Proceedings of the Royal Society of\nLondon. A. Mathematical and Physical Sciences 400, 97\n(1985).\n\n\n[11] D.\nDeutsch and R. Jozsa, Rapid solution of problems\nby quantum computation, Proceedings of the Royal Society of London.\nSeries A: Mathematical and Physical Sciences 439, 553\n(1992).\n\n\n[12] E.\nBernstein and U. Vazirani, Quantum\nComplexity Theory, SIAM Journal on Computing\n26, 1411 (1997).\n\n\n[13] D.\nR. Simon, On the\nPower of Quantum Computation, SIAM Journal\non Computing 26, 1474 (1997).\n\n\n[14] P.\nW. Shor, Algorithms for Quantum\nComputation: Discrete Logarithms and Factoring, in\nProceedings 35th Annual Symposium on\nFoundations of Computer Science (IEEE\nComput. Soc. Press, Santa Fe, NM, USA, 1994), pp. 124–134.\n\n\n[15] L.\nK. Grover, A Fast\nQuantum Mechanical Algorithm for Database Search, in\nProceedings of the Twenty-Eighth Annual ACM Symposium\non Theory of Computing - STOC ’96 (ACM\nPress, Philadelphia, Pennsylvania, United States, 1996), pp.\n212–219.\n\n\n[16] W.\nK. Wootters and W. H. Zurek, A single quantum cannot be\ncloned, Nature 299, 802 (1982).\n\n\n[17] M.\nM. Wilde, Quantum Information Theory, 2nd ed (Cambridge\nuniversity press, Cambridge, 2017).\n\n\n[18] A.\nEinstein, B. Podolsky, and N. Rosen, Can\nQuantum-Mechanical Description of Physical Reality Be\nConsidered Complete?, Physical Review 47,\n777 (1935).\n\n\n[19] E.\nSchrödinger, Discussion of\nProbability Relations between Separated\nSystems, Mathematical Proceedings of the Cambridge\nPhilosophical Society 31, 555 (1935).\n\n\n[20] J.\nS. Bell, On the\nEinstein Podolsky Rosen paradox, Physics Physique\nFizika 1, 195 (1964).\n\n\n[21] S.\nJ. Freedman and J. F. Clauser, Experimental\nTest of Local Hidden-Variable Theories,\nPhysical Review Letters 28, 938 (1972).\n\n\n[22] A.\nAspect, J. Dalibard, and G. Roger, Experimental\nTest of Bell’s Inequalities Using Time-\nVarying Analyzers, Physical Review Letters\n49, 1804 (1982).\n\n\n[23] M.\nF. Pusey, J. Barrett, and T. Rudolph, On the reality of the quantum\nstate, Nature Physics 8, 475 (2012).\n\n\n[24] N.\nD. Mermin, Bringing home the\natomic world: Quantum mysteries for anybody, American\nJournal of Physics 49, 940 (1981).\n\n\n[25] R.\nHorodecki, M. Horodecki, and K. Horodecki, Quantum\nentanglement, Reviews of Modern Physics 81, 865\n(2009).\n\n\n[26] W.\nWootters, Entanglement of formation and concurrence, Quantum Information\nand Computation 1, 27 (2001).\n\n\n[27] D.\nM. Greenberger, M. A. Horne, A. Shimony, and A. Zeilinger, Bell’s theorem without\ninequalities, American Journal of Physics 58, 1131\n(1990).\n\n\n[28] W.\nDür, G. Vidal, and J. I. Cirac, Three qubits can be\nentangled in two inequivalent ways, Physical Review A\n62, 62314 (2000).\n\n\n[29] N.\nP. De Leon, K. M. Itoh, D. Kim, K. K. Mehta, T. E. Northup, H. Paik, B.\nS. Palmer, N. Samarth, S. Sangtawesin, and D. W. Steuerman, Materials challenges and\nopportunities for quantum computing hardware, Science\n372, eabb2823 (2021).",
    "crumbs": [
      "References"
    ]
  }
]