<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>2&nbsp; The Qubit – Quantum Technology</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./summary.html" rel="next">
<link href="./intro.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-e26003cea8cd680ca0c55a263523d882.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark-d166b450ba5a8e9f7a0ab969bf6592c1.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-b7c2d8834e08b04a63bb76a724ffbcac.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark-c1966a8c70583a3816b1e3a216c1caf1.min.css" rel="prefetch" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script>
window.MathJax = {
  tex: {
    macros: {
      tr: "\\operatorname{tr}"
    }
  }
};
</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./qubit.html"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">The Qubit</span></a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">Quantum Technology</a> 
        <div class="sidebar-tools-main">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./intro.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./qubit.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">The Qubit</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./summary.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Summary</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#the-qubit-hilbert-space" id="toc-the-qubit-hilbert-space" class="nav-link active" data-scroll-target="#the-qubit-hilbert-space"><span class="header-section-number">2.1</span> The Qubit Hilbert space</a>
  <ul class="collapse">
  <li><a href="#qubit-states" id="toc-qubit-states" class="nav-link" data-scroll-target="#qubit-states"><span class="header-section-number">2.1.1</span> Qubit states</a></li>
  <li><a href="#qubit-operators" id="toc-qubit-operators" class="nav-link" data-scroll-target="#qubit-operators"><span class="header-section-number">2.1.2</span> Qubit operators</a></li>
  <li><a href="#the-pauli-operators" id="toc-the-pauli-operators" class="nav-link" data-scroll-target="#the-pauli-operators"><span class="header-section-number">2.1.3</span> The Pauli operators</a></li>
  </ul></li>
  <li><a href="#sec-bloch-sphere" id="toc-sec-bloch-sphere" class="nav-link" data-scroll-target="#sec-bloch-sphere"><span class="header-section-number">2.2</span> The Bloch sphere</a>
  <ul class="collapse">
  <li><a href="#general-unitary-rotations" id="toc-general-unitary-rotations" class="nav-link" data-scroll-target="#general-unitary-rotations"><span class="header-section-number">2.2.1</span> General Unitary Rotations</a></li>
  <li><a href="#the-phase-gate" id="toc-the-phase-gate" class="nav-link" data-scroll-target="#the-phase-gate"><span class="header-section-number">2.2.2</span> The Phase Gate</a></li>
  </ul></li>
  <li><a href="#quantum-circuits" id="toc-quantum-circuits" class="nav-link" data-scroll-target="#quantum-circuits"><span class="header-section-number">2.3</span> Quantum Circuits</a></li>
  <li><a href="#noise-and-decoherence" id="toc-noise-and-decoherence" class="nav-link" data-scroll-target="#noise-and-decoherence"><span class="header-section-number">2.4</span> Noise and decoherence</a>
  <ul class="collapse">
  <li><a href="#the-density-matrix" id="toc-the-density-matrix" class="nav-link" data-scroll-target="#the-density-matrix"><span class="header-section-number">2.4.1</span> The Density Matrix</a></li>
  <li><a href="#modeling-noise" id="toc-modeling-noise" class="nav-link" data-scroll-target="#modeling-noise"><span class="header-section-number">2.4.2</span> Modeling Noise</a></li>
  <li><a href="#physical-qubit-implementations" id="toc-physical-qubit-implementations" class="nav-link" data-scroll-target="#physical-qubit-implementations"><span class="header-section-number">2.4.3</span> Physical Qubit Implementations</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">The Qubit</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>The fundamental building block of the classical computer was the bit: A 0 or 1 that could be manipulated by a classical computer (via transistors, see <a href="intro.html#sec-transistors" class="quarto-xref"><span>Section 1.2</span></a>). In a similar manner, quantum computation has the “quantum bit” or just <em>qubit</em>, for short. This leads us to the linear algebra of <span class="math inline">\(2\times 2\)</span> matrices, as we will see. Despite the apparent simplicity, we can already see many of the key features of quantum mechanics in this simple system.</p>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Common Qubit Misconceptions
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>A qubit is not just a probabilistic classical bit.</li>
<li>You cannot directly access of the amplitudes of <span class="math inline">\(\ket{0}\)</span> and <span class="math inline">\(\ket{1}\)</span> through a single measurement.</li>
<li>Superposition states collapse upon measurement.</li>
<li>No-cloning theorem <span class="citation" data-cites="WoottersZurek1982">&nbsp;[<a href="references.html#ref-WoottersZurek1982" role="doc-biblioref">1</a>]</span> means you cannot perfectly copy an unknown quantum state.</li>
<li>Entanglement is not the same as classical correlation (see next chapter).</li>
</ul>
</div>
</div>
<section id="the-qubit-hilbert-space" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="the-qubit-hilbert-space"><span class="header-section-number">2.1</span> The Qubit Hilbert space</h2>
<p>A qubit will be in two-dimensional complex vector space equipped with an inner product.</p>
<section id="qubit-states" class="level3" data-number="2.1.1">
<h3 data-number="2.1.1" class="anchored" data-anchor-id="qubit-states"><span class="header-section-number">2.1.1</span> Qubit states</h3>
<p>For the qubit, we associate two states with two different basis vectors: <span class="math inline">\(\ket{0}\)</span> and <span class="math inline">\(\ket{1}\)</span>. This will be called the <em>computational basis</em>. The magic<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> of quantum mechanics is that a state need not be just one or the other, but could be <em>any</em> linear superposition of these <span id="eq-qubit"><span class="math display">\[
\ket{\psi} = \alpha \ket{0} + \beta \ket{1}.
\tag{2.1}\]</span></span> In this, we have adopted the <em>bra-ket</em> notation due to Dirac. While it can be quite useful, we can write this in terms of matrices and vectors <span class="math display">\[
\ket{0} = \begin{bmatrix} 1 \\ 0 \end{bmatrix}, \quad \ket{1} = \begin{bmatrix} 0 \\ 1 \end{bmatrix}.
\]</span> This makes it clear that these states are <em>orthogonal</em> <span class="math inline">\(\braket{0|1} = 0\)</span>.</p>
<p>In this case we have <span class="math display">\[
\ket{\psi} = \begin{bmatrix} \alpha \\ \beta \end{bmatrix}.
\]</span> We also need the conjugate transpose, the Hermitian conjugate, of this vector, which will be a row-vector <span class="math display">\[
\bra{\psi} = \begin{bmatrix} \alpha^* &amp; \beta^* \end{bmatrix}.
\]</span> The key feature of quantum mechanics is that these states must be <em>normalized</em>, meaning that the probability of finding the system in any state must sum to 1. This means that <span class="math display">\[
\braket{\psi|\psi} = \begin{bmatrix} \alpha^* &amp; \beta^* \end{bmatrix} \begin{bmatrix} \alpha \\ \beta \end{bmatrix} = |\alpha|^2 + |\beta|^2 = 1.
\]</span> In matrix notation, this is just the dot product of a vector with its complex conjugate.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Why Normalization Matters
</div>
</div>
<div class="callout-body-container callout-body">
<p>The normalization condition <span class="math inline">\(|\alpha|^2 + |\beta|^2 = 1\)</span> isn’t just mathematical convenience - it ensures probabilities add up to 100%! For example:</p>
<ul>
<li><span class="math inline">\(\ket{\psi} = \frac{1}{\sqrt{2}}(\ket{0} + \ket{1})\)</span> gives 50-50 chance of measuring 0 or 1</li>
<li><span class="math inline">\(\ket{\psi} = \frac{\sqrt{3}}{2}\ket{0} + \frac{1}{2}\ket{1}\)</span> gives 75% chance of 0 and 25% chance of 1</li>
</ul>
</div>
</div>
<p>We can also write operators that act on these states. The simplest operator is the Pauli <span class="math inline">\(Z\)</span> operator, which in matrix form is <span class="math display">\[
Z = \begin{bmatrix} 1 &amp; 0 \\ 0 &amp; -1 \end{bmatrix}.
\]</span> When this operator acts on our basis states, we find <span class="math display">\[
Z\ket{0} = \ket{0}, \quad Z\ket{1} = -\ket{1}.
\]</span> This means that <span class="math inline">\(\ket{0}\)</span> and <span class="math inline">\(\ket{1}\)</span> are <em>eigenstates</em> of <span class="math inline">\(Z\)</span> with eigenvalues <span class="math inline">\(+1\)</span> and <span class="math inline">\(-1\)</span> respectively. For a general state <span class="math inline">\(\ket{\psi}\)</span>, measuring <span class="math inline">\(Z\)</span> will yield either <span class="math inline">\(+1\)</span> or <span class="math inline">\(-1\)</span>, with probabilities determined by <span class="math inline">\(|\alpha|^2\)</span> and <span class="math inline">\(|\beta|^2\)</span> respectively.</p>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<strong>Example</strong>: Measuring a superposition state
</div>
</div>
<div class="callout-body-container callout-body">
<p>Consider the state <span class="math inline">\(\ket{\psi} = \frac35\ket{0} + \frac45\ket{1}\)</span>. When we measure this state in the <span class="math inline">\(Z\)</span> basis:</p>
<p>Notice that this state is normalized since <span class="math inline">\((\frac{3}{5})^2 + (\frac{4}{5})^2 = 1\)</span>. If we measure this state in the computational basis:</p>
<ul>
<li>We’ll get outcome <span class="math inline">\(\ket{0}\)</span> with probability <span class="math inline">\(|\frac{3}{5}|^2 = 0.36\)</span> (36%)</li>
<li>We’ll get outcome <span class="math inline">\(\ket{1}\)</span> with probability <span class="math inline">\(|\frac{4}{5}|^2 = 0.64\)</span> (64%)</li>
</ul>
<p>After measurement, the state will collapse to either <span class="math inline">\(\ket{0}\)</span> or <span class="math inline">\(\ket{1}\)</span> with the above probabilities</p>
</div>
</div>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Measurement Collapse in Practice
</div>
</div>
<div class="callout-body-container callout-body">
<p>When we say a quantum state “collapses” upon measurement, what actually happens in the lab?</p>
<ul>
<li>For a superconducting qubit: We measure a voltage or current</li>
<li>For an ion trap: We detect scattered photons</li>
<li>For a photonic qubit: We count photons with a detector</li>
</ul>
<p>Each technology has its own way of converting quantum information into classical signals!</p>
</div>
</div>
</section>
<section id="qubit-operators" class="level3" data-number="2.1.2">
<h3 data-number="2.1.2" class="anchored" data-anchor-id="qubit-operators"><span class="header-section-number">2.1.2</span> Qubit operators</h3>
<p>Since this is linear algebra, we can write a general operator <span class="math inline">\(\mathcal O\)</span> as a matrix <span class="math display">\[
\mathcal O = \begin{bmatrix} a &amp; b \\ c &amp; d \end{bmatrix}.
\]</span> Often, we are interested in the eigenvalues and eigenstates of these operators <span class="math inline">\(\mathcal O \ket{\psi_{i}} = \lambda_i \ket{\psi_i}\)</span>. Generically, we can find these by solving a polynomial equation <span class="math display">\[
\det(\mathcal O - \lambda I) = 0.
\]</span></p>
<p>Solving this step-by-step <span class="math display">\[
\det(\mathcal O - \lambda I) = \begin{vmatrix} a-\lambda &amp; b \\ c &amp; d-\lambda \end{vmatrix} = 0,
\]</span> which gives us <span class="math display">\[
(a-\lambda)(d-\lambda) - bc = 0.
\]</span> This is a quadratic equation that we can solve: <span class="math display">\[
\lambda^2 - (a+d)\lambda + (ad-bc) = 0.
\]</span></p>
<p>The eigenvalues are therefore <span id="eq-evals-two-by-two"><span class="math display">\[
\lambda_{\pm} = \frac{a+d \pm \sqrt{(a-d)^2 + 4bc}}{2}.
\tag{2.2}\]</span></span></p>
<p>For quantum mechanical <strong>observables</strong> (see <a href="intro.html#sec-postulate-observable" class="quarto-xref"><span>Section 1.3.2</span></a>), we are particularly interested in <em>Hermitian</em> operators where <span class="math inline">\(\mathcal O = \mathcal O^\dagger\)</span>, <span class="math display">\[
\begin{bmatrix} a &amp; b \\ c &amp; d \end{bmatrix} = \begin{bmatrix} a^* &amp; c^* \\ b^* &amp; d^* \end{bmatrix}
\]</span> This means that <span class="math inline">\(a\)</span> and <span class="math inline">\(d\)</span> must be real and <span class="math inline">\(c = b^*\)</span>. In this case, the eigenvalues are always real, as we can see from the <a href="#eq-evals-two-by-two" class="quarto-xref">Eq.&nbsp;<span>2.2</span></a>.</p>
<p>A particularly important class of operators are <strong>unitary operators</strong>, where <span class="math inline">\(U^\dagger U = UU^\dagger = I\)</span>. These are what we use for time-evolution, see <a href="intro.html#sec-postulate-unitary" class="quarto-xref"><span>Section 1.3.3</span></a>.</p>
<p>These operators preserve the inner product between states: <span class="math display">\[
\braket{U\psi|U\phi} = \braket{\psi|\phi}
\]</span> For a <span class="math inline">\(2\times 2\)</span> matrix <span class="math display">\[
U = \begin{bmatrix} a &amp; b \\ c &amp; d \end{bmatrix},
\]</span> the unitarity condition means that <span class="math display">\[
\begin{bmatrix} a^* &amp; c^* \\ b^* &amp; d^* \end{bmatrix} \begin{bmatrix} a &amp; b \\ c &amp; d \end{bmatrix} = \begin{bmatrix} 1 &amp; 0 \\ 0 &amp; 1 \end{bmatrix}.
\]</span></p>
<p>This gives us several conditions:</p>
<ol type="1">
<li><span class="math inline">\(|a|^2 + |c|^2 = 1\)</span> (normalization of first column)</li>
<li><span class="math inline">\(|b|^2 + |d|^2 = 1\)</span> (normalization of second column)</li>
<li><span class="math inline">\(ab^* + cd^* = 0\)</span> (orthogonality of columns)</li>
</ol>
<p>This immediately gives us some insight into these operators. If we define, <span class="math display">\[
\ket{\psi_1} = \begin{bmatrix} a \\ c \end{bmatrix}, \quad \ket{\psi_2} = \begin{bmatrix} b \\ d \end{bmatrix},
\]</span> then we have <span class="math inline">\(\braket{\psi_1|\psi_1} = 1 = \braket{\psi_2|\psi_2}\)</span> and <span class="math inline">\(\braket{\psi_1|\psi_2} = 0\)</span>.</p>
<p>An important property of unitary operators is that their eigenvalues always have magnitude 1, meaning they can be written as <span class="math inline">\(e^{i\theta}\)</span> for some real <span class="math inline">\(\theta\)</span>. This makes them natural operators for describing quantum evolution.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Why Unitary?
</div>
</div>
<div class="callout-body-container callout-body">
<p>Unitary operators are special because they:</p>
<ol type="1">
<li>Preserve the normalization of quantum states</li>
<li>Are reversible (have an inverse)</li>
<li>Represent physical operations that conserve probability</li>
</ol>
<p>This is why quantum gates must be unitary - they represent real physical processes that can be undone!</p>
</div>
</div>
</section>
<section id="the-pauli-operators" class="level3" data-number="2.1.3">
<h3 data-number="2.1.3" class="anchored" data-anchor-id="the-pauli-operators"><span class="header-section-number">2.1.3</span> The Pauli operators</h3>
<p>A particularly important set of operators are the Pauli operators. We’ve already seen the Pauli <span class="math inline">\(Z\)</span> operator. The other two are<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> <span class="math display">\[
X = \begin{bmatrix} 0 &amp; 1 \\ 1 &amp; 0 \end{bmatrix}, \quad Y = \begin{bmatrix} 0 &amp; -i \\ i &amp; 0 \end{bmatrix}.
\]</span> These operators satisfy some important algebraic relations: <span class="math display">\[
X^2 = Y^2 = Z^2 = I, \quad XY = iZ, \quad YZ = iX, \quad ZX = iY.
\]</span> We can additionally start to see some logical operations begin to appear; <span class="math inline">\(X\)</span> operates on the computational basis as a <strong>NOT</strong> gate <span class="math display">\[
X \ket{0} = \ket{1}, \quad X \ket{1} = \ket{0}.
\]</span></p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Pauli Operators in Action
</div>
</div>
<div class="callout-body-container callout-body">
<p>The Pauli operators represent quantum operations:</p>
<ul>
<li><span class="math inline">\(X\)</span> is like the classical NOT gate: flips between <span class="math inline">\(\ket{0}\)</span> and <span class="math inline">\(\ket{1}\)</span></li>
<li><span class="math inline">\(Z\)</span> adds a phase: leaves <span class="math inline">\(\ket{0}\)</span> alone but negates <span class="math inline">\(\ket{1}\)</span></li>
<li><span class="math inline">\(Y = iXZ\)</span> combines both operations.</li>
</ul>
<p>These simple operations are building blocks for more complex quantum algorithms!</p>
</div>
</div>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<strong>Example</strong>: Applying operators
</div>
</div>
<div class="callout-body-container callout-body">
<p>Let’s apply the X (NOT) gate to our state <span class="math inline">\(\ket{\psi} = (\tfrac{3}{5}\ket{0} + \tfrac{4}{5}\ket{1})\)</span>: <span class="math display">\[
\begin{aligned}
X\ket{\psi} &amp;= X(\tfrac{3}{5}\ket{0} + \tfrac{4}{5}\ket{1}) \\
&amp;= \tfrac{3}{5}X\ket{0} + \tfrac{4}{5}X\ket{1} \\
&amp;= \tfrac{3}{5}\ket{1} + \tfrac{4}{5}\ket{0} \\
&amp;= \tfrac{4}{5}\ket{0} + \tfrac{3}{5}\ket{1}
\end{aligned}
\]</span></p>
</div>
</div>
<p>The full set of Pauli operators, along with the identity, form a complete basis for <span class="math inline">\(2\times 2\)</span> matrices, meaning we can write any operator as <span class="math display">\[
\mathcal O = aI + bX + cY + dZ,
\]</span> where <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, <span class="math inline">\(c\)</span>, and <span class="math inline">\(d\)</span> are complex numbers. We can extract each of these numbers, mathematically, with a trace operation <span class="math display">\[
\tr \mathcal O = 2a, \quad \tr \mathcal O X = 2b, \quad \tr \mathcal O Y = 2c, \quad \tr \mathcal O Z = 2d.
\]</span> Note that separately, <span class="math inline">\(X\)</span>, <span class="math inline">\(Y\)</span>, and <span class="math inline">\(Z\)</span> are Hermitian (and thus, observables). If <span class="math inline">\(\mathcal O\)</span> is an observable, then <span class="math inline">\(\mathcal O = \mathcal O^\dagger\)</span> immediately leads us to <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span>, <span class="math inline">\(c\)</span>, and <span class="math inline">\(d\)</span> being all real.</p>
<p>We can put constraints on these coefficients for unitary operators as well, and we leave this as an exercise for the reader.</p>
<p>Finally, these operators have eigenstates as well, and we can define them as <span class="math inline">\(X\ket{\pm} = \pm \ket{\pm}\)</span> and <span class="math inline">\(Y\ket{\pm i} = \pm \ket{\pm i}\)</span>, and they have the forms <span class="math display">\[
\begin{aligned}
    \ket{\pm} &amp; = \tfrac1{\sqrt2}(\ket 0 \pm \ket 1), \\
    \ket{\pm i} &amp; = \tfrac1{\sqrt2}(\ket 0 \pm i \ket 1).
\end{aligned}
\]</span></p>
<p>We will often want to change our basis from <span class="math inline">\(\ket{0}\)</span> and <span class="math inline">\(\ket{1}\)</span> to <span class="math inline">\(\ket{+}\)</span> and <span class="math inline">\(\ket{-}\)</span>. This is accomplished with something called the <em>Hadamard gate</em> (we’ll call it <span class="math inline">\(H\)</span>, not to be confused with a Hamiltonian) and it is created specifically to change from computational basis to the <span class="math inline">\(X\)</span> basis: <span class="math inline">\(H \ket{0} = \ket{+}\)</span> and <span class="math inline">\(H \ket{1} = \ket{-}\)</span>. As a matrix it takes the form <span class="math display">\[
H = \frac1{\sqrt{2}}\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; -1 \end{bmatrix}.
\]</span></p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
The Power of Hadamard
</div>
</div>
<div class="callout-body-container callout-body">
<p>The Hadamard gate is one of the most important gates in quantum computing with useful properties:</p>
<ol type="1">
<li>It creates equal superpositions from computational basis states.</li>
<li>It’s its own inverse (<span class="math inline">\(H^2 = I\)</span>)</li>
<li>It’s used in nearly every quantum algorithm</li>
<li>When applied to <span class="math inline">\(n\)</span> qubits, it creates a superposition of all <span class="math inline">\(2^n\)</span> possible bit strings!</li>
</ol>
</div>
</div>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<strong>Example 3</strong>: The Hadamard Transform
</div>
</div>
<div class="callout-body-container callout-body">
<p>The Hadamard gate is particularly important because it creates superposition states. Let’s see what happens when we apply it to <span class="math inline">\(\ket{0}\)</span>: <span class="math display">\[
\begin{aligned}
H\ket{0} &amp;= \frac{1}{\sqrt{2}}\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; -1 \end{bmatrix}\begin{bmatrix} 1 \\ 0 \end{bmatrix} \\
&amp;= \frac{1}{\sqrt{2}}\begin{bmatrix} 1 \\ 1 \end{bmatrix} \\
&amp;= \frac{1}{\sqrt{2}}(\ket{0} + \ket{1}) \\
&amp;= \ket{+}
\end{aligned}
\]</span></p>
</div>
</div>
</section>
</section>
<section id="sec-bloch-sphere" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="sec-bloch-sphere"><span class="header-section-number">2.2</span> The Bloch sphere</h2>
<p>The qubit itself is more than just a probability of being a 1 or a 0. A crucial bit of <em>quantum</em> information is the relative phase between the two states for instance <span class="math display">\[
\ket{\psi} = \tfrac1{\sqrt2}( \ket 0 + e^{i\phi} \ket 1),
\]</span> and since all states are equivalent up to a <em>total</em> phase, we can write the amplitude of each state with a real number. In this case, if we set <span class="math inline">\(\ket{\psi} = x \ket{0} + y e^{i\phi} \ket 1\)</span>, then we have <span class="math inline">\(\braket{\psi|\psi} = x^2 + y^2 = 1\)</span> for normalization. This is the equation for a circle, and writing out <span class="math inline">\(x = \cos(\theta/2)\)</span> and <span class="math inline">\(y = \sin(\theta/2)\)</span><a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a>, we are lead to an angular representation of our state. <span id="eq-bloch-sphere"><span class="math display">\[
\ket{\psi} = \cos(\theta/2) \ket{0} + \sin(\theta/2)e^{i\phi} \ket{1}.
\tag{2.3}\]</span></span> Let’s see how this state relates to our Pauli operators. If we calculate the expectation values of each operator:</p>
<p><span class="math display">\[
\begin{aligned}
\langle X \rangle &amp;= \bra{\psi}X\ket{\psi} \\
&amp;= (\cos(\theta/2) \bra{0} + \sin(\theta/2)e^{-i\phi} \bra{1})
   X
   (\cos(\theta/2) \ket{0} + \sin(\theta/2)e^{i\phi} \ket{1}) \\
&amp;= (\cos(\theta/2) \bra{0} + \sin(\theta/2)e^{-i\phi} \bra{1})
   (\cos(\theta/2) \ket{1} + \sin(\theta/2)e^{i\phi} \ket{0}) \\
&amp;= \sin(\theta/2)\cos(\theta/2) e^{i\phi} + \cos(\theta/2)\sin(\theta/2)e^{-i\phi} \\
&amp;= \sin(\theta/2)\cos(\theta/2) (e^{i\phi} + e^{-i\phi}) \\
&amp;= 2\sin(\theta/2)\cos(\theta/2) \cos\phi \\
&amp;= \sin \theta \cos\phi.
\end{aligned}
\]</span> We can carry out a similar calculation for <span class="math inline">\(Y\)</span> and <span class="math inline">\(Z\)</span> to obtain <span class="math display">\[
\begin{aligned}
\langle X \rangle &amp;= \bra{\psi}X\ket{\psi} = \sin\theta\cos\phi \\
\langle Y \rangle &amp;= \bra{\psi}Y\ket{\psi} = \sin\theta\sin\phi \\
\langle Z \rangle &amp;= \bra{\psi}Z\ket{\psi} = \cos\theta
\end{aligned}
\]</span></p>
<p>These expectation values give us coordinates , which are precisely the coordinates of a point on a unit sphere! This is why we call it the Bloch sphere. The angles <span class="math inline">\(\theta\)</span> and <span class="math inline">\(\phi\)</span> are the usual spherical coordinates.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
The Bloch Sphere Geometry
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>The north pole (<span class="math inline">\(\theta=0\)</span>) corresponds to <span class="math inline">\(\ket{0}\)</span></li>
<li>The south pole (<span class="math inline">\(\theta=\pi\)</span>) corresponds to <span class="math inline">\(\ket{1}\)</span></li>
<li>The equator (<span class="math inline">\(\theta=\pi/2\)</span>) contains equal superposition of computational basis states:
<ul>
<li><span class="math inline">\(\phi=0\)</span> gives <span class="math inline">\(\ket{+}\)</span> (positive x-axis)</li>
<li><span class="math inline">\(\phi=\pi\)</span> gives <span class="math inline">\(\ket{-}\)</span> (negative x-axis)</li>
<li><span class="math inline">\(\phi=\pi/2\)</span> gives <span class="math inline">\(\ket{+i}\)</span> (positive y-axis)</li>
<li><span class="math inline">\(\phi=3\pi/2\)</span> gives <span class="math inline">\(\ket{-i}\)</span> (negative y-axis)</li>
</ul></li>
</ul>
</div>
</div>
<div id="fig-bloch-sphere" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-bloch-sphere-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="qubit_files/mediabag/bloch-sphere.svg" class="img-fluid figure-img">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-bloch-sphere-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Fig.&nbsp;2.1: The Bloch sphere showing eigenstates of X, Y, and Z Pauli operators
</figcaption>
</figure>
</div>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Example: Hadamard Gate on <span class="math inline">\(\ket{0}\)</span>
</div>
</div>
<div class="callout-body-container callout-body">
<p>The Hadamard gate <span class="math inline">\(H\)</span> takes the state <span class="math inline">\(\ket{0}\)</span> (north pole) to <span class="math inline">\(\ket{+}\)</span> (on the equator at <span class="math inline">\(\phi=0\)</span>). In terms of the Bloch sphere coordinates, this means:</p>
<ul>
<li>Starting point: <span class="math inline">\(\theta=0\)</span> (north pole)</li>
<li>Ending point: <span class="math inline">\(\theta=\pi/2\)</span>, <span class="math inline">\(\phi=0\)</span> (positive x-axis)</li>
</ul>
<p>The gate effectively rotates the state by 90° around the y-axis. Similarly, <span class="math inline">\(H\ket{1}\)</span> takes the south pole to <span class="math inline">\(\ket{-}\)</span> on the negative x-axis.</p>
</div>
</div>
<section id="general-unitary-rotations" class="level3" data-number="2.2.1">
<h3 data-number="2.2.1" class="anchored" data-anchor-id="general-unitary-rotations"><span class="header-section-number">2.2.1</span> General Unitary Rotations</h3>
<p>The Hadamard example shows how unitary gates can rotate states on the Bloch sphere. More generally, any single-qubit unitary operation can be thought of as a rotation of the Bloch sphere. Let’s see how this works.</p>
<p>A general rotation around a unit vector <span class="math inline">\(\vec{n} = (n_x, n_y, n_z)\)</span> by angle <span class="math inline">\(\theta\)</span> is given by <span class="math display">\[
R_{\vec{n}}(\theta) = \cos(\theta/2)I - i\sin(\theta/2)(n_xX + n_yY + n_zZ).
\]</span></p>
<p>For example:</p>
<ul>
<li>Rotation around z-axis: <span class="math display">\[ R_z(\theta) = e^{-i\theta Z/2} = \begin{bmatrix} e^{-i\theta/2} &amp; 0 \\ 0 &amp; e^{i\theta/2} \end{bmatrix} \]</span></li>
<li>Rotation around x-axis: <span class="math display">\[ R_x(\theta) = e^{-i\theta X/2} = \begin{bmatrix} \cos(\theta/2) &amp; -i\sin(\theta/2) \\ -i\sin(\theta/2) &amp; \cos(\theta/2) \end{bmatrix} \]</span></li>
<li>Rotation around y-axis: <span class="math display">\[R_y(\theta) = e^{-i\theta Y/2} = \begin{bmatrix} \cos(\theta/2) &amp; -\sin(\theta/2) \\ \sin(\theta/2) &amp; \cos(\theta/2) \end{bmatrix}\]</span></li>
</ul>
<p>A remarkable fact is that any single-qubit unitary operation can be decomposed into three rotations around two different axes. This is known as the Euler angle decomposition: <span class="math display">\[
U = e^{i\alpha}R_z(\phi)R_y(\theta)R_z(\psi)
\]</span> where <span class="math inline">\(\alpha\)</span>, <span class="math inline">\(\phi\)</span>, <span class="math inline">\(\theta\)</span>, and <span class="math inline">\(\psi\)</span> are real numbers. The global phase <span class="math inline">\(e^{i\alpha}\)</span> is often unimportant for quantum computing purposes.</p>
<div class="callout callout-style-default callout-tip callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Visualizing Rotations
</div>
</div>
<div class="callout-body-container callout-body">
<p>The Euler angle decomposition has a nice geometric interpretation:</p>
<ol type="1">
<li>First rotation (<span class="math inline">\(R_z(\psi)\)</span>): Rotate around z-axis</li>
<li>Second rotation (<span class="math inline">\(R_y(\theta)\)</span>): Tilt to new latitude</li>
<li>Third rotation (<span class="math inline">\(R_z(\phi)\)</span>): Rotate to final longitude</li>
<li>Global phase (<span class="math inline">\(e^{i\alpha}\)</span>): Invisible in measurements</li>
</ol>
<p>This is similar to how we specify points on Earth using latitude and longitude!</p>
</div>
</div>
</section>
<section id="the-phase-gate" class="level3" data-number="2.2.2">
<h3 data-number="2.2.2" class="anchored" data-anchor-id="the-phase-gate"><span class="header-section-number">2.2.2</span> The Phase Gate</h3>
<p>The phase gate (often denoted as <span class="math inline">\(S\)</span>) is another important single-qubit gate that adds a phase of <span class="math inline">\(i\)</span> to the <span class="math inline">\(\ket{1}\)</span> state while leaving <span class="math inline">\(\ket{0}\)</span> unchanged:</p>
<p><span class="math display">\[
S = \begin{bmatrix} 1 &amp; 0 \\ 0 &amp; i \end{bmatrix}
\]</span></p>
<p>When acting on basis states: <span class="math display">\[
S\ket{0} = \ket{0}, \quad S\ket{1} = i\ket{1}
\]</span></p>
<p>The phase gate is equivalent to a <span class="math inline">\(\pi/2\)</span> rotation around the z-axis: <span class="math inline">\(S = R_z(\pi/2)\)</span>. On the Bloch sphere, this corresponds to rotating a state by 90° around the z-axis.</p>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<strong>Example</strong>: Phase Gate on Superposition
</div>
</div>
<div class="callout-body-container callout-body">
<p>Let’s see what happens when we apply <span class="math inline">\(S\)</span> to an equal superposition state:</p>
<p><span class="math display">\[
\begin{aligned}
S\ket{+} &amp;= S\left(\frac{1}{\sqrt{2}}(\ket{0} + \ket{1})\right) \\
&amp;= \frac{1}{\sqrt{2}}(S\ket{0} + S\ket{1}) \\
&amp;= \frac{1}{\sqrt{2}}(\ket{0} + i\ket{1})
\end{aligned}
\]</span></p>
<p>This transforms <span class="math inline">\(\ket{+}\)</span> into <span class="math inline">\(\ket{+i}\)</span>, rotating it from the positive x-axis to the positive y-axis on the Bloch sphere.</p>
</div>
</div>
<p>The phase gate is particularly important in quantum error correction and quantum algorithms where controlled phase operations are needed.</p>
<p>More generically, we can create any <span class="math inline">\(R_z(\phi)\)</span> gate to perform rotations about the <span class="math inline">\(z\)</span>-axis (this is very useful for Shor’s algorithm). However, a common variant is the <span class="math inline">\(T\)</span> gate, which is simply <span class="math inline">\(R_z(\pi/4)\)</span> and is one of the minimal components needed to achieve universal quantum computation.</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Phase gate leaves computational basis states alone
</div>
</div>
<div class="callout-body-container callout-body">
<p>Note that these gates only change superposition of computational basis states, so <span class="math inline">\(S \ket{0} = \ket{0}\)</span> and <span class="math inline">\(S\ket{1} = i \ket{1}\)</span>. (Similarly for any gate made from rotations about the z-axis.)</p>
</div>
</div>
</section>
</section>
<section id="quantum-circuits" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="quantum-circuits"><span class="header-section-number">2.3</span> Quantum Circuits</h2>
<p>Now that we’ve covered the key single-qubit operations, we can start to think about how to represent sequences of these operations graphically using quantum circuits. In quantum circuits:</p>
<ul>
<li>Qubits are represented as horizontal lines (called “wires”, see <a href="#fig-single-qubit" class="quarto-xref">Fig.&nbsp;<span>2.2</span></a>).</li>
<li>Gates are boxes or symbols placed on these wires (see <a href="#fig-qubit-XZ-gates" class="quarto-xref">Fig.&nbsp;<span>2.3</span></a> and <a href="#fig-qubit-HS-gates" class="quarto-xref">Fig.&nbsp;<span>2.4</span></a>).</li>
<li>Time flows from left to right.</li>
<li>Measurements are represented by meters (see <a href="#fig-qubit-measure" class="quarto-xref">Fig.&nbsp;<span>2.5</span></a>).</li>
</ul>
<p>Often, unless we are preparing a specific state for an algorithm, we may leave off the states from the ends of the “wire.” This wire, <a href="#fig-single-qubit" class="quarto-xref">Fig.&nbsp;<span>2.2</span></a>, you can think of as the identity.</p>
<div id="fig-single-qubit" class="quarto-layout-panel">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-single-qubit-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 33.3%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="qubit_files/mediabag/qubit-identity-0.svg" class="img-fluid figure-img"></p>
<figcaption>Identity on <span class="math inline">\(\ket{0}\)</span></figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 33.3%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="qubit_files/mediabag/qubit-identity-1.svg" class="img-fluid figure-img"></p>
<figcaption>Identity on <span class="math inline">\(\ket{1}\)</span></figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 33.3%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="qubit_files/mediabag/qubit-identity.svg" class="img-fluid figure-img"></p>
<figcaption>Identity on <span class="math inline">\(\ket{\psi}\)</span></figcaption>
</figure>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-single-qubit-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Fig.&nbsp;2.2: Lines representing the evolution of a qubit (no gates applied)
</figcaption>
</figure>
</div>
<p>While in quantum state evolution we apply operators right-to-left, the two operations <span class="math inline">\(X \ket{0} = \ket{1}\)</span> and <span class="math inline">\(Z \ket{+} = \ket{-}\)</span> are represented in <a href="#fig-qubit-XZ-gates" class="quarto-xref">Fig.&nbsp;<span>2.3</span></a>.</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Important
</div>
</div>
<div class="callout-body-container callout-body">
<p>The Pauli operators are both unitary and Hermitian, so they perform as quantum gates (which require unitary as <a href="intro.html#sec-postulate-unitary" class="quarto-xref"><span>Section 1.3.3</span></a> stipulates) and as observables (as <a href="intro.html#sec-postulate-observable" class="quarto-xref"><span>Section 1.3.2</span></a> stipulates).</p>
</div>
</div>
<div id="fig-qubit-XZ-gates" class="quarto-layout-panel">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-qubit-XZ-gates-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="qubit_files/mediabag/qubit-X-gate.svg" class="img-fluid figure-img"></p>
<figcaption>Application of the <span class="math inline">\(X\)</span> gate.</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="qubit_files/mediabag/qubit-Z-gate.svg" class="img-fluid figure-img"></p>
<figcaption>Application of the <span class="math inline">\(Z\)</span> gate.</figcaption>
</figure>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-qubit-XZ-gates-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Fig.&nbsp;2.3: Examples of the Pauli operators as gates.
</figcaption>
</figure>
</div>
<p>The Hadamard and phase gates can also be mixed in, <a href="#fig-qubit-HS-gates" class="quarto-xref">Fig.&nbsp;<span>2.4</span></a>, and we can even introduce the meter symbol for measurements, <a href="#fig-qubit-measure" class="quarto-xref">Fig.&nbsp;<span>2.5</span></a>.</p>
<div id="fig-qubit-HS-gates" class="quarto-layout-panel">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-qubit-HS-gates-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="qubit_files/mediabag/qubit-H-gate.svg" class="img-fluid figure-img"></p>
<figcaption>Application of the Hadamard gate</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="qubit_files/mediabag/qubit-S-gate.svg" class="img-fluid figure-img"></p>
<figcaption>Application of the phase gate</figcaption>
</figure>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-qubit-HS-gates-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Fig.&nbsp;2.4: Examples of the Hadamard and phase gates.
</figcaption>
</figure>
</div>
<div id="fig-qubit-measure" class="quarto-layout-panel">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-qubit-measure-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="qubit_files/mediabag/qubit-X-gate-measure.svg" class="img-fluid figure-img"></p>
<figcaption>Will measure 1 with 100% probability</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="qubit_files/mediabag/qubit-H-gate-measure.svg" class="img-fluid figure-img"></p>
<figcaption>Will measure 1 with 50% probability</figcaption>
</figure>
</div>
</div>
</div>
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-qubit-measure-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Fig.&nbsp;2.5: Examples of measurements. The meter is assumed to be measuring in the computational basis unless otherwise noted (i.e., measuring the <span class="math inline">\(Z\)</span> operator).
</figcaption>
</figure>
</div>
<p>Whenever measurements are performed, we will often transform to the computational basis <span class="math inline">\(\ket{0}\)</span> and <span class="math inline">\(\ket{1}\)</span> to perform a measurement. By playing tricks with unitary transformations, we can measure other observables by mixing unitaries and measurements of the computational basis; dependent on the platform, this may or may not be necessary. In terms of diagrams, you should assume meters are measurements in the computational basis unless it is noted otherwise.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Reading Quantum Circuits
</div>
</div>
<div class="callout-body-container callout-body">
<p>Quantum circuits are read from left to right, just like reading text. Each horizontal line represents a qubit’s journey through time, and the boxes show what operations happen and when.</p>
<p>The measurement symbol at the end indicates when we extract classical information from our quantum system.</p>
</div>
</div>
<p>These diagrams give us a powerful visual language for describing quantum computations. Even complex algorithms can be broken down into sequences of these basic operations.</p>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<strong>Example</strong>: Gate Sequences
</div>
</div>
<div class="callout-body-container callout-body">
<p>Consider applying <span class="math inline">\(H\)</span> then <span class="math inline">\(Z\)</span> then <span class="math inline">\(H\)</span> to <span class="math inline">\(\ket{0}\)</span>:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="qubit_files/mediabag/qubit-HZH-gate-measure.svg" class="img-fluid figure-img"></p>
<figcaption>Implementing an <span class="math inline">\(X\)</span> gate with <span class="math inline">\(Z\)</span> and <span class="math inline">\(H\)</span>.</figcaption>
</figure>
</div>
<ol type="1">
<li><span class="math inline">\(H\ket{0} = \ket{+}\)</span> (move to +x axis)</li>
<li><span class="math inline">\(Z\ket{+} = \frac{1}{\sqrt{2}}(\ket{0} - \ket{1})\)</span> (rotate around z by 90°)</li>
<li><span class="math inline">\(H(\frac{1}{\sqrt{2}}(\ket{0} - \ket{1})) = \ket{1}\)</span> (move to -z axis)</li>
</ol>
<p>This sequence effectively implements the <span class="math inline">\(X\)</span> gate!</p>
</div>
</div>
</section>
<section id="noise-and-decoherence" class="level2" data-number="2.4">
<h2 data-number="2.4" class="anchored" data-anchor-id="noise-and-decoherence"><span class="header-section-number">2.4</span> Noise and decoherence</h2>
<p>A large part of the course will consist of finding physical systems where we can identify certain states as <span class="math inline">\(\ket{0}\)</span> and <span class="math inline">\(\ket{1}\)</span>, and then proceed to figure out how to perform the gates we need for quantum algorithms. In this way, this course could be called “two-level systems and where to find them.” However, these states are not pristine and so we need a way to talk about states that subject to noisy environments and loss of information.</p>
<p>In fact, environmental interactions can cause, amongst other issues:</p>
<ul>
<li>Loss of phase information (dephasing)</li>
<li>Loss of energy (amplitude damping)</li>
<li>Random bit flips</li>
</ul>
<p>To properly describe these noise processes, we need to move beyond pure state descriptions and introduce the density matrix formalism.</p>
<section id="the-density-matrix" class="level3" data-number="2.4.1">
<h3 data-number="2.4.1" class="anchored" data-anchor-id="the-density-matrix"><span class="header-section-number">2.4.1</span> The Density Matrix</h3>
<p>For a pure quantum state <span class="math inline">\(\ket{\psi}\)</span>, the density matrix is defined as <span class="math display">\[
\rho = \ket{\psi}\bra{\psi}
\]</span> For example, the computational basis states have density matrices: <span class="math display">\[
\ket{0}\bra{0} = \begin{bmatrix} 1 &amp; 0 \\ 0 &amp; 0 \end{bmatrix}, \quad
\ket{1}\bra{1} = \begin{bmatrix} 0 &amp; 0 \\ 0 &amp; 1 \end{bmatrix}
\]</span></p>
<p>The density matrix also provides a convenient way to calculate expectation values of observables. For any observable <span class="math inline">\(A\)</span>, the expectation value is given by: <span class="math display">\[
\langle A \rangle = \tr(A\rho)
\]</span> For a pure state <span class="math inline">\(\ket{\psi}\)</span>, this reduces to our familiar expression: <span class="math display">\[
\tr(A\ket{\psi}\bra{\psi}) = \bra{\psi}A\ket{\psi}
\]</span></p>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<strong>Example</strong>: Measuring <span class="math inline">\(Z\)</span> with the Density Matrix
</div>
</div>
<div class="callout-body-container callout-body">
<p>Consider measuring <span class="math inline">\(Z\)</span> for the state <span class="math inline">\(\ket{+} = \frac{1}{\sqrt{2}}(\ket{0} + \ket{1})\)</span>:</p>
<p>The density matrix is: <span class="math display">\[
\rho_+ = \frac{1}{2}\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 1 \end{bmatrix}
\]</span></p>
<p>Using the formula for expecation values with <span class="math inline">\(Z = \begin{bmatrix} 1 &amp; 0 \\ 0 &amp; -1 \end{bmatrix}\)</span>: <span class="math display">\[
\langle Z \rangle = \tr(Z\rho_+) = \tr\left(\frac{1}{2}\begin{bmatrix} 1 &amp; 0 \\ 0 &amp; -1 \end{bmatrix}\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 1 \end{bmatrix}\right) = 0
\]</span></p>
<p>This matches what we expect: <span class="math inline">\(\ket{+}\)</span> has equal probability of measuring <span class="math inline">\(\pm 1\)</span> for <span class="math inline">\(Z\)</span>.</p>
</div>
</div>
<p>The real power of density matrices comes from describing <em>mixed states</em>, which are statistical mixtures of pure states: <span class="math display">\[
\rho = \sum_i p_i \ket{\psi_i}\bra{\psi_i}
\]</span> where <span class="math inline">\(p_i\)</span> are classical probabilities (<span class="math inline">\(p_i \geq 0\)</span>, <span class="math inline">\(\sum_i p_i = 1\)</span>).</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Properties of Density Matrices
</div>
</div>
<div class="callout-body-container callout-body">
<p>Any valid density matrix must satisfy:</p>
<ol type="1">
<li>Hermiticity: <span class="math inline">\(\rho = \rho^\dagger\)</span></li>
<li>Positive semidefinite: <span class="math inline">\(\bra{\phi}\rho\ket{\phi} \geq 0\)</span> for all <span class="math inline">\(\ket{\phi}\)</span></li>
<li>Unit trace: <span class="math inline">\(\tr(\rho) = 1\)</span></li>
<li>For pure states: <span class="math inline">\(\tr(\rho^2) = 1\)</span></li>
<li>For mixed states: <span class="math inline">\(\tr(\rho^2) &lt; 1\)</span></li>
</ol>
</div>
</div>
<section id="quantum-operations-with-density-matrices" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="quantum-operations-with-density-matrices">Quantum Operations with Density Matrices</h4>
<p>Just as we can evolve pure states with unitary operators, we can evolve density matrices. For a unitary operation <span class="math inline">\(U\)</span>, the density matrix transforms as: <span class="math display">\[
\rho \rightarrow U\rho U^\dagger
\]</span> This preserves all the properties of the density matrix we discussed above.</p>
<p>When we make a measurement, we use projection operators <span class="math inline">\(\{P_m\}\)</span> (like <span class="math inline">\(\ket{0}\bra{0}\)</span> and <span class="math inline">\(\ket{1}\bra{1}\)</span> for measuring in the computational basis). The probability of getting outcome <span class="math inline">\(m\)</span> is: <span class="math display">\[
p(m) = \tr(P_m \rho)
\]</span> After measuring and getting outcome <span class="math inline">\(m\)</span>, the state “collapses” to: <span class="math display">\[
\rho_m = \frac{P_m \rho P_m}{\tr(P_m \rho)}
\]</span> where the denominator ensures the trace remains 1.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Quantum Channels
</div>
</div>
<div class="callout-body-container callout-body">
<p>The density matrix formalism really shines when describing general quantum evolution, including noise. Any physical process (unitary or not) can be described by a quantum channel <span class="math inline">\(\mathcal{E}\)</span>: <span class="math display">\[
\rho \rightarrow \mathcal{E}(\rho) = \sum_k E_k \rho E_k^\dagger
\]</span> The operators <span class="math inline">\(E_k\)</span> (called Kraus operators) satisfy <span class="math inline">\(\sum_k E_k^\dagger E_k = I\)</span> to preserve probability. This includes both ideal unitary evolution (one <span class="math inline">\(E_k = U\)</span>) and noise processes (multiple <span class="math inline">\(E_k\)</span>), as we’ll see in the next section.</p>
</div>
</div>
</section>
<section id="density-matrices-and-the-bloch-sphere" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="density-matrices-and-the-bloch-sphere">Density Matrices and the Bloch Sphere</h4>
<p>The density matrix formalism provides a beautiful geometric picture when combined with the Bloch sphere representation in <a href="#sec-bloch-sphere" class="quarto-xref"><span>Section 2.2</span></a>. While pure states live on the surface of the Bloch sphere, mixed states live <em>inside</em> it. Any density matrix for a single qubit can be written as: <span class="math display">\[
\rho = \frac{1}{2}(I + \vec{r}\cdot\vec{\sigma})
\]</span> where <span class="math inline">\(\vec{r} = (r_x, r_y, r_z)\)</span> is called the Bloch vector and <span class="math inline">\(\vec{\sigma} = (X,Y,Z)\)</span> are the Pauli matrices.</p>
<p>The length of <span class="math inline">\(\vec{r}\)</span> determines how mixed the state is:</p>
<ul>
<li>For pure states, <span class="math inline">\(|\vec{r}| = 1\)</span> (surface of sphere)</li>
<li>For mixed states, <span class="math inline">\(|\vec{r}| &lt; 1\)</span> (inside sphere)</li>
<li>For the maximally mixed state, <span class="math inline">\(\vec{r} = 0\)</span> (center of sphere)</li>
</ul>
<p>This gives us an intuitive picture of decoherence: noise processes like dephasing and bit flips move the Bloch vector inward from the surface, representing the loss of quantum information. The maximally mixed state at the center represents complete loss of information–equal probabilities for all measurement outcomes.</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Connection to Purity
</div>
</div>
<div class="callout-body-container callout-body">
<p>The length of the Bloch vector is directly related to the purity <span class="math inline">\(\tr(\rho^2)\)</span> we discussed earlier: <span class="math display">\[
\tr(\rho^2) = \frac{1 + |\vec{r}|^2}{2}
\]</span> This confirms that pure states (<span class="math inline">\(|\vec{r}| = 1\)</span>) have purity 1, while mixed states have purity less than 1.</p>
</div>
</div>
</section>
</section>
<section id="modeling-noise" class="level3" data-number="2.4.2">
<h3 data-number="2.4.2" class="anchored" data-anchor-id="modeling-noise"><span class="header-section-number">2.4.2</span> Modeling Noise</h3>
<p>A full discussion of different quantum channels can be found in <span class="citation" data-cites="Wilde2017">&nbsp;[<a href="references.html#ref-Wilde2017" role="doc-biblioref">3</a>]</span>. Here, we discuss some of the ones relevant for loss of quantum information.</p>
<p>The language of density matrices allows us to describe some of the errors that can occur in a precise manner</p>
<section id="random-bit-flips" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="random-bit-flips">Random bit-flips</h4>
<p>If there is probability <span class="math inline">\(p\)</span> that a bit is flipped, we can encode this within a change of the density matrix: <span class="math display">\[
\rho \rightarrow (1-p)\rho + p X\rho X,
\]</span> where the first term describes the probability that the density matrix remains unchanged and the second describe the process of randomly flipping a bit.</p>
</section>
<section id="dephasing" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="dephasing">Dephasing</h4>
<p>As we’ve already mentioned the phase between <span class="math inline">\(\ket{0}\)</span> and <span class="math inline">\(\ket{1}\)</span> is useful information that we will take advantage of. However, some physical processes can scramble this phase in a way that could be inherently difficult to parse, in that case we can describe these processes with “dephasing” <span class="math display">\[
\rho \rightarrow (1-p)\rho + p Z \rho Z.
\]</span> This process has a clear action on <span class="math inline">\(\rho\)</span> when <span class="math inline">\(p=1/2\)</span>. To illustrate this, consider <span class="math inline">\(\ket{\psi} = \alpha \ket{0} + \beta \ket{1}\)</span>, this has a probability of measuring <span class="math inline">\(0\)</span> of <span class="math inline">\(|\alpha|^2\)</span> and a probabilty of measuring <span class="math inline">\(1\)</span> of <span class="math inline">\(|\beta|^2\)</span>, but there is also phase information between <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span> that tells us where on the Bloch sphere the state is located. Dephasing will eliminate this phase information.</p>
<p>To see this, the full density matrix before we apply dephasing is <span class="math display">\[
\rho = \begin{bmatrix} |\alpha|^2 &amp; \alpha\beta^* \\ \alpha^*\beta &amp; |\beta|^2 \end{bmatrix},
\]</span> and after dephasing we will have the density matrix <span class="math display">\[
\frac12 \rho + \frac12 Z \rho Z = \begin{bmatrix} |\alpha|^2 &amp; 0 \\ 0 &amp; |\beta|^2 \end{bmatrix}.
\]</span> The off-diagonal components carried the relative phase information and it is now entirely lost, leaving us with a classical mixture of <span class="math inline">\(\ket{0}\)</span> and <span class="math inline">\(\ket{1}\)</span></p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Measurement as Dephasing
</div>
</div>
<div class="callout-body-container callout-body">
<p>This process of losing phase information is exactly what happens when we measure a quantum state in a particular basis! When we measure in the computational basis (<span class="math inline">\(\{\ket{0}, \ket{1}\}\)</span>), we are effectively performing complete dephasing - we destroy all phase information between the basis states and are left with only the classical probabilities. This is why measurement is often described as “collapsing” the quantum state into classical information.</p>
<p>This connection between measurement and dephasing illustrates a fundamental aspect of quantum mechanics: the act of gaining classical information about a quantum system necessarily destroys some of its quantum properties, as formalized in the measurement postulates we discussed earlier.</p>
</div>
</div>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<strong>Example</strong>: Dephasing of a Superposition State
</div>
</div>
<div class="callout-body-container callout-body">
<p>Consider the state <span class="math inline">\(\ket{+} = \frac{1}{\sqrt{2}}(\ket{0} + \ket{1})\)</span> under dephasing:</p>
<p>Initial density matrix: <span class="math display">\[
\rho_0 = \frac{1}{2}\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 1 \end{bmatrix}
\]</span></p>
<p>After dephasing with probability <span class="math inline">\(p\)</span>: <span class="math display">\[
\rho(p) = \frac{1}{2}\begin{bmatrix} 1 &amp; (1-2p) \\ (1-2p) &amp; 1 \end{bmatrix}
\]</span></p>
<p>Complete dephasing (<span class="math inline">\(p=\frac{1}{2}\)</span>) yields the maximally mixed state: <span class="math display">\[
\rho(\tfrac{1}{2}) = \frac{1}{2}\begin{bmatrix} 1 &amp; 0 \\ 0 &amp; 1 \end{bmatrix}
\]</span></p>
</div>
</div>
</section>
<section id="depolarizing" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="depolarizing">Depolarizing</h4>
<p>The depolarizing channel represents one of the most severe forms of noise in quantum systems, often considered the “worst-case scenario” for quantum information. This channel transforms any input state into a mixture of itself and the maximally mixed state: <span class="math display">\[
\rho \rightarrow (1-p)\rho + p \frac{I}{2},
\]</span> where <span class="math inline">\(p\)</span> represents the probability of depolarization. When <span class="math inline">\(p=1\)</span>, the state becomes completely mixed regardless of the input: <span class="math display">\[
\rho \rightarrow \frac{1}{2}I.
\]</span></p>
<p>Note that this has eliminated any information about <span class="math inline">\(\ket{\psi}\)</span>!</p>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<strong>Example</strong>: The Pauli Twirl
</div>
</div>
<div class="callout-body-container callout-body">
<p>An interesting way to understand the depolarizing channel is through what’s called the “Pauli twirl”. The depolarizing channel can be written as a random application of Pauli operators: <span class="math display">\[
\rho \rightarrow (1-p)\rho + \frac{p}{3}(X\rho X + Y\rho Y + Z\rho Z).
\]</span></p>
<p>This means we can implement depolarizing noise by randomly applying X, Y, or Z gates with probability <span class="math inline">\(p/3\)</span> each. This is particularly useful in quantum error correction, where we often want to simulate noise in a way that’s easy to analyze.</p>
</div>
</div>
</section>
<section id="amplitude-damping" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="amplitude-damping">Amplitude Damping</h4>
<p>In many physical systems, one can lose information by having emission of energy. Physically, this could be an atom in some energy level and it emits a photon, falling to a lower energy level. One can imagine a process like this occuring with an operator <span class="math display">\[
E_0 = \sqrt{\gamma} \ket{0} \bra{1},
\]</span> which describes the process of taking an occupied state <span class="math inline">\(\ket{1}\)</span> and transforming it to <span class="math inline">\(\ket{0}\)</span> with probability <span class="math inline">\(\gamma\)</span>. To fully encode this into a change in the density matrix, we need one other operator: the chance that nothing happens. A natural guess would be <span class="math display">\[
E_1 = \ket{0}\bra{0} + \sqrt{1-\gamma} \ket{1}\bra{1},
\]</span> which describes that there is unit probability of remaining <span class="math inline">\(\ket{0}\)</span> and probaiblity <span class="math inline">\(1-\gamma\)</span> of remaining in <span class="math inline">\(\ket{1}\)</span> if you start there.</p>
<p>The full operation on the density matrix is then <span class="math display">\[
\rho \rightarrow E_1 \rho E_1^\dagger + E_0 \rho E_0^\dagger
\]</span></p>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<strong>Example</strong>: Amplitude Damping in Action
</div>
</div>
<div class="callout-body-container callout-body">
<p>Let’s see how amplitude damping affects a simple superposition state. Consider the initial state <span class="math display">\[
\ket{\psi} = \frac{1}{\sqrt{2}}(\ket{0} + \ket{1}),
\]</span> which has density matrix <span class="math display">\[
\rho = \frac{1}{2}\begin{bmatrix} 1 &amp; 1 \\ 1 &amp; 1 \end{bmatrix}.
\]</span></p>
<p>After applying amplitude damping with probability <span class="math inline">\(\gamma\)</span>, the state becomes <span class="math display">\[
\begin{aligned}
\rho' &amp;= E_1 \rho E_1^\dagger + E_0 \rho E_0^\dagger \\
&amp;= \frac{1}{2}\begin{bmatrix} 1+\gamma &amp; \sqrt{1-\gamma} \\ \sqrt{1-\gamma} &amp; 1-\gamma \end{bmatrix}.
\end{aligned}
\]</span></p>
<p>We can see that:</p>
<ul>
<li>The probability of being in <span class="math inline">\(\ket{1}\)</span> decreases by <span class="math inline">\(\gamma\)</span></li>
<li>The probability of being in <span class="math inline">\(\ket{0}\)</span> increases by <span class="math inline">\(\gamma\)</span></li>
<li>The off-diagonal coherence terms decay by <span class="math inline">\(\sqrt{1-\gamma}\)</span></li>
</ul>
<p>When <span class="math inline">\(\gamma = 1\)</span> (complete damping), the state becomes <span class="math display">\[
\rho' = \begin{bmatrix} 1 &amp; 0 \\ 0 &amp; 0 \end{bmatrix} = \ket{0}\bra{0},
\]</span> representing complete relaxation to the ground state.</p>
</div>
</div>
</section>
<section id="erasure-channel" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="erasure-channel">Erasure Channel</h4>
<p>Another important quantum channel is the erasure channel, which models the loss of a qubit to other accessible states. Unlike amplitude damping, where information leaks gradually, the erasure channel represents a complete loss of the qubit with probability <span class="math inline">\(\epsilon\)</span>. When this happens, the qubit is replaced by an “error state” that we denote as <span class="math inline">\(\ket{e}\)</span>. Importantly, <span class="math inline">\(\ket{e}\)</span> exists in a different part of the Hilbert space than our qubit states - it’s an additional state that flags that erasure has occurred.</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Orthogonality of Error State
</div>
</div>
<div class="callout-body-container callout-body">
<p>The error state <span class="math inline">\(\ket{e}\)</span> is orthogonal to both <span class="math inline">\(\ket{0}\)</span> and <span class="math inline">\(\ket{1}\)</span>, meaning <span class="math inline">\(\braket{e|0} = \braket{e|1} = 0\)</span>. This is crucial as it represents a state completely outside our original qubit space but still within the system itself.</p>
</div>
</div>
<p>The erasure can then be represented by <span class="math display">\[
\rho \mapsto (1 - \epsilon)\rho + \epsilon \ket{e}\bra{e}.
\]</span></p>
<p>In particular, this process</p>
<ul>
<li>Preserves the state with probability <span class="math inline">\(1-\epsilon\)</span></li>
<li>Erases it completely with probability <span class="math inline">\(\epsilon\)</span>, replacing it with the error state <span class="math inline">\(\ket{e}\)</span></li>
</ul>
<div class="callout callout-style-default callout-note no-icon callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon no-icon"></i>
</div>
<div class="callout-title-container flex-fill">
<strong>Example</strong>: Erasure Channel in Action
</div>
</div>
<div class="callout-body-container callout-body">
<p>Since the erasure channel operates in an enlarged Hilbert space that includes the error state (in this case, making it 3-dimensional), let’s consider our superposition state embedded in this expanded space: <span class="math display">\[
\ket{\psi} = \frac{1}{\sqrt{2}}(\ket{0} + \ket{1}) = \frac{1}{\sqrt{2}}(\ket{0} + \ket{1}) = \frac{1}{\sqrt{2}}\begin{bmatrix} 1 \\ 1 \\ 0 \end{bmatrix}.
\]</span> After the erasure channel acts, the state becomes a mixed state: <span class="math display">\[
\rho' = (1-\epsilon)\begin{bmatrix}
1/2 &amp; 1/2 &amp; 0 \\
1/2 &amp; 1/2 &amp; 0 \\
0 &amp; 0 &amp; 0
\end{bmatrix} + \epsilon\begin{bmatrix}
0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 1
\end{bmatrix}
= \begin{bmatrix}
\frac{1-\epsilon}{2} &amp; \frac{1-\epsilon}{2} &amp; 0 \\
\frac{1-\epsilon}{2} &amp; \frac{1-\epsilon}{2} &amp; 0 \\
0 &amp; 0 &amp; \epsilon
\end{bmatrix}
\]</span> This represents that with probability <span class="math inline">\(1-\epsilon\)</span> we still have our original state in the upper-left <span class="math inline">\(2\times2\)</span> block, but with probability <span class="math inline">\(\epsilon\)</span> we have completely lost it to the error state, represented by the 1 in the bottom-right corner.</p>
</div>
</div>
<p>The erasure channel is particularly important in quantum communication and error correction because the error state exists within the system Hilbert space itself (not the environment). This additional state in the system allows us to track and flag when errors occur–making it especially useful for quantum error correction protocols, unlike other noise channels where the errors are unknown and harder to detect.</p>
</section>
</section>
<section id="physical-qubit-implementations" class="level3" data-number="2.4.3">
<h3 data-number="2.4.3" class="anchored" data-anchor-id="physical-qubit-implementations"><span class="header-section-number">2.4.3</span> Physical Qubit Implementations</h3>
<p>The quest for building practical quantum computers has led to several different approaches for implementing qubits. Each implementation aims to create a physical system that can reliably represent quantum states and allow for precise control and manipulation. We will explore in detail later what is needed for a good quantum device, but give a brief overview here of <em>what</em> the devices are.</p>
<section id="superconducting-qubits" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="superconducting-qubits">Superconducting Qubits</h4>
<ul>
<li>Qubit are energy levels of <em>charge</em> or <em>flux</em> within a superconducting circuit.</li>
<li>Based on superconducting circuits using Josephson junctions.</li>
<li>Operate at extremely low temperatures (~20 mK).</li>
<li>Used by: IBM, Google, Rigetti.</li>
</ul>
</section>
<section id="trapped-ion-qubits" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="trapped-ion-qubits">Trapped Ion Qubits</h4>
<ul>
<li>Qubits are electronic or nuclear states of individual ions</li>
<li>Ions held in electromagnetic traps, manipulated by lasers</li>
<li>Used by: IonQ, Honeywell-Quantinuum</li>
</ul>
</section>
<section id="photonic-qubits" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="photonic-qubits">Photonic Qubits</h4>
<ul>
<li>Qubits are properites of light (e.g., polarization)</li>
<li>Can operate at room temperature</li>
<li>Used by: PsiQuantum, Xanadu</li>
</ul>
</section>
<section id="semiconductor-quantum-dots" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="semiconductor-quantum-dots">Semiconductor Quantum Dots</h4>
<ul>
<li>Qubits can be encoded using either:
<ul>
<li><em>charge</em> states (electron occupying different quantum dots)</li>
<li><em>spin</em> states (up/down spin states of an electron)</li>
</ul></li>
<li>Created by confining electrons in semiconductor nanostructures</li>
<li>Often called “artificial atoms” due to their discrete energy levels</li>
<li>Active research at: Intel, TU Delft, Princeton, UNSW, CEA-Leti</li>
</ul>
</section>
<section id="nv-centers-in-diamond" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="nv-centers-in-diamond">NV Centers in Diamond</h4>
<ul>
<li>The nitrogen vacancy defects in diamond provide energy levels accessible with light.</li>
<li>Can operate at room temperature</li>
<li>Applications in quantum sensing and networking</li>
</ul>
</section>
<section id="topological-qubits" class="level4 unnumbered">
<h4 class="unnumbered anchored" data-anchor-id="topological-qubits">Topological Qubits</h4>
<ul>
<li>Qubits are non-local and topologically protected states within an exotic (topological) state of matter.</li>
<li>Most promising candidate: Majorana zero modes</li>
<li><strong>Current Status</strong>:
<ul>
<li>Active research at Microsoft and Delft</li>
<li>Recent progress in identifying Majorana signatures in nanowires</li>
<li>Debate continues over experimental evidence</li>
</ul></li>
</ul>
<p>As we’ll discuss, the “perfect” qubit would combine long coherence times, fast gates, high fidelity, easy coupling to other qubits, and straightforward scalability. While each implementation has made significant progress, achieving all these properties simultaneously remains a major challenge in the field.</p>


<div id="refs" class="references csl-bib-body" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-WoottersZurek1982" class="csl-entry" role="listitem">
<div class="csl-left-margin">[1] </div><div class="csl-right-inline">W. K. Wootters and W. H. Zurek, <a href="https://doi.org/10.1038/299802a0">A single quantum cannot be cloned</a>, Nature <strong>299</strong>, 802 (1982).</div>
</div>
<div id="ref-BravyiKitaev2005" class="csl-entry" role="listitem">
<div class="csl-left-margin">[2] </div><div class="csl-right-inline">S. Bravyi and A. Kitaev, <a href="https://doi.org/10.1103/PhysRevA.71.022316">Universal quantum computation with ideal <span>Clifford</span> gates and noisy ancillas</a>, Physical Review A <strong>71</strong>, 022316 (2005).</div>
</div>
<div id="ref-Wilde2017" class="csl-entry" role="listitem">
<div class="csl-left-margin">[3] </div><div class="csl-right-inline">M. M. Wilde, <em>Quantum Information Theory</em>, 2nd ed (Cambridge university press, Cambridge, 2017).</div>
</div>
</div>
</section>
</section>
</section>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr>
<ol>
<li id="fn1"><p>Magic is a technical term in quantum computing, though we’re using it in a colloquial sense here, see <span class="citation" data-cites="BravyiKitaev2005">&nbsp;[<a href="references.html#ref-BravyiKitaev2005" role="doc-biblioref">2</a>]</span>.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>In some literature, these are matrices are denoted by <span class="math inline">\(\sigma_{x}\)</span>, <span class="math inline">\(\sigma_y\)</span>, and <span class="math inline">\(\sigma_z\)</span> and related to spin operators via <span class="math inline">\(S_i =\frac12 \sigma_i\)</span>. This insight can help bridge the idea of these operators and the Bloch sphere.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>The divide-by-two for the angles will become clear as we go through this section.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./intro.html" class="pagination-link" aria-label="Introduction">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">Introduction</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./summary.html" class="pagination-link" aria-label="Summary">
        <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Summary</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>