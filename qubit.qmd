# The Qubit 

The fundamental building block of the classical computer was the bit: A 0 or 1 that could be manipulated by a classical computer (via transistors, see @sec-transistors).
In a similar manner, quantum computation has the "quantum bit" or just _qubit_, for short.  This leads us to the linear algebra of $2\times 2$ matrices, as we will see. Despite the apparent simplicity, we can already see many of the key features of quantum mechanics in this simple system.

## The Qubit Hilbert space

A qubit will be in two-dimensional complex vector space equipped with an inner product.

### Qubit states

For the qubit, we associate two states with two different basis vectors: $\ket{0}$ and $\ket{1}$. This will be called the _computational basis_. The magic[^1] of quantum mechanics is that a state need not be just one or the other, but could be _any_ linear superposition of these
$$
\ket{\psi} = \alpha \ket{0} + \beta \ket{1}.
$$ {#eq-qubit}
In this, we have adopted the _bra-ket_ notation due to Dirac. While it can be quite useful, we can write this in terms of matrices and vectors
$$
\ket{0} = \begin{bmatrix} 1 \\ 0 \end{bmatrix}, \quad \ket{1} = \begin{bmatrix} 0 \\ 1 \end{bmatrix}.
$$
This makes it clear that these states are _orthogonal_ $\braket{0|1} = 0$.

In this case we have
$$
\ket{\psi} = \begin{bmatrix} \alpha \\ \beta \end{bmatrix}.
$$
We also need the conjugate transpose, the Hermitian conjugate, of this vector, which will be a row-vector
$$
\bra{\psi} = \begin{bmatrix} \alpha^* & \beta^* \end{bmatrix}.
$$
The key feature of quantum mechanics is that these states must be _normalized_, meaning that the probability of finding the system in any state must sum to 1. This means that
$$
\braket{\psi|\psi} = \begin{bmatrix} \alpha^* & \beta^* \end{bmatrix} \begin{bmatrix} \alpha \\ \beta \end{bmatrix} = |\alpha|^2 + |\beta|^2 = 1.
$$
In matrix notation, this is just the dot product of a vector with its complex conjugate.

::: {.callout-note}
## Why Normalization Matters
The normalization condition $|\alpha|^2 + |\beta|^2 = 1$ isn't just mathematical convenience - it ensures probabilities add up to 100%! For example:

- $\ket{\psi} = \frac{1}{\sqrt{2}}(\ket{0} + \ket{1})$ gives 50-50 chance of measuring 0 or 1
- $\ket{\psi} = \frac{\sqrt{3}}{2}\ket{0} + \frac{1}{2}\ket{1}$ gives 75% chance of 0 and 25% chance of 1
:::

We can also write operators that act on these states. The simplest operator is the Pauli $Z$ operator, which in matrix form is
$$
Z = \begin{bmatrix} 1 & 0 \\ 0 & -1 \end{bmatrix}.
$$
When this operator acts on our basis states, we find
$$
Z\ket{0} = \ket{0}, \quad Z\ket{1} = -\ket{1}.
$$
This means that $\ket{0}$ and $\ket{1}$ are _eigenstates_ of $Z$ with eigenvalues $+1$ and $-1$ respectively. For a general state $\ket{\psi}$, measuring $Z$ will yield either $+1$ or $-1$, with probabilities determined by $|\alpha|^2$ and $|\beta|^2$ respectively.

::: {.callout-note icon=false}
## **Example**: Measuring a superposition state

Consider the state $\ket{\psi} = \frac35\ket{0} + \frac45\ket{1}$. When we measure this state in the $Z$ basis:

Notice that this state is normalized since $(\frac{3}{5})^2 + (\frac{4}{5})^2 = 1$. If we measure this state in the computational basis:

- We'll get outcome $\ket{0}$ with probability $|\frac{3}{5}|^2 = 0.36$ (36%)
- We'll get outcome $\ket{1}$ with probability $|\frac{4}{5}|^2 = 0.64$ (64%)

After measurement, the state will collapse to either $\ket{0}$ or $\ket{1}$ with the above probabilities
:::

::: {.callout-warning}
## Measurement Collapse in Practice
When we say a quantum state "collapses" upon measurement, what actually happens in the lab?

- For a superconducting qubit: We measure a voltage or current
- For an ion trap: We detect scattered photons
- For a photonic qubit: We count photons with a detector

Each technology has its own way of converting quantum information into classical signals!
:::
### Qubit operators

Since this is linear algebra, we can write a general operator $\mathcal O$ as a matrix
$$
\mathcal O = \begin{bmatrix} a & b \\ c & d \end{bmatrix}.
$$
Often, we are interested in the eigenvalues and eigenstates of these operators $\mathcal O \ket{\psi_{i}} = \lambda_i \ket{\psi_i}$. 
Generically, we can find these by solving a polynomial equation
$$
\det(\mathcal O - \lambda I) = 0.
$$

Solving this step-by-step
$$
\det(\mathcal O - \lambda I) = \begin{vmatrix} a-\lambda & b \\ c & d-\lambda \end{vmatrix} = 0,
$$
which gives us
$$
(a-\lambda)(d-\lambda) - bc = 0.
$$
This is a quadratic equation that we can solve:
$$
\lambda^2 - (a+d)\lambda + (ad-bc) = 0.
$$

The eigenvalues are therefore
$$
\lambda_{\pm} = \frac{a+d \pm \sqrt{(a-d)^2 + 4bc}}{2}.
$$ {#eq-evals-two-by-two}

For quantum mechanical **observables** (see @sec-postulate-observable), we are particularly interested in _Hermitian_ operators where $\mathcal O = \mathcal O^\dagger$, 
$$
\begin{bmatrix} a & b \\ c & d \end{bmatrix} = \begin{bmatrix} a^* & c^* \\ b^* & d^* \end{bmatrix}
$$
This means that $a$ and $d$ must be real and $c = b^*$. In this case, the eigenvalues are always real, as we can see from the @eq-evals-two-by-two.

A particularly important class of operators are **unitary operators**, where $U^\dagger U = UU^\dagger = I$. These are what we use for time-evolution, see @sec-postulate-unitary.

These operators preserve the inner product between states:
$$
\braket{U\psi|U\phi} = \braket{\psi|\phi}
$$
For a $2\times 2$ matrix
$$
U = \begin{bmatrix} a & b \\ c & d \end{bmatrix},
$$
the unitarity condition means that
$$
\begin{bmatrix} a^* & c^* \\ b^* & d^* \end{bmatrix} \begin{bmatrix} a & b \\ c & d \end{bmatrix} = \begin{bmatrix} 1 & 0 \\ 0 & 1 \end{bmatrix}.
$$

This gives us several conditions:

1. $|a|^2 + |c|^2 = 1$ (normalization of first column)
2. $|b|^2 + |d|^2 = 1$ (normalization of second column)
3. $ab^* + cd^* = 0$ (orthogonality of columns)

This immediately gives us some insight into these operators. If we define,
$$
\ket{\psi_1} = \begin{bmatrix} a \\ c \end{bmatrix}, \quad \ket{\psi_2} = \begin{bmatrix} b \\ d \end{bmatrix},
$$
then we have $\braket{\psi_1|\psi_1} = 1 = \braket{\psi_2|\psi_2}$ and $\braket{\psi_1|\psi_2} = 0$.

An important property of unitary operators is that their eigenvalues always have magnitude 1, meaning they can be written as $e^{i\theta}$ for some real $\theta$. This makes them natural operators for describing quantum evolution.

::: {.callout-note}
## Why Unitary?
Unitary operators are special because they:

1. Preserve the normalization of quantum states
2. Are reversible (have an inverse)
3. Represent physical operations that conserve probability

This is why quantum gates must be unitary - they represent real physical processes that can be undone!
:::

### The Pauli operators

A particularly important set of operators are the Pauli operators. We've already seen the Pauli $Z$ operator. The other two are[^2]
$$
X = \begin{bmatrix} 0 & 1 \\ 1 & 0 \end{bmatrix}, \quad Y = \begin{bmatrix} 0 & -i \\ i & 0 \end{bmatrix}.
$$
These operators satisfy some important algebraic relations:
$$
X^2 = Y^2 = Z^2 = I, \quad XY = iZ, \quad YZ = iX, \quad ZX = iY.
$$
We can additionally start to see some logical operations begin to appear; $X$ operates on the computational basis as a **NOT** gate
$$
X \ket{0} = \ket{1}, \quad X \ket{1} = \ket{0}.
$$

::: {.callout-tip}
## Pauli Operators in Action
The Pauli operators represent quantum operations:

- $X$ is like the classical NOT gate: flips between $\ket{0}$ and $\ket{1}$
- $Z$ adds a phase: leaves $\ket{0}$ alone but negates $\ket{1}$
- $Y = iXZ$ combines both operations.
   
These simple operations are building blocks for more complex quantum algorithms!
:::

::: {.callout-note icon="false"}
## **Example**: Applying operators
Let's apply the X (NOT) gate to our state $\ket{\psi} = (\tfrac{3}{5}\ket{0} + \tfrac{4}{5}\ket{1})$:
$$
\begin{aligned}
X\ket{\psi} &= X(\tfrac{3}{5}\ket{0} + \tfrac{4}{5}\ket{1}) \\
&= \tfrac{3}{5}X\ket{0} + \tfrac{4}{5}X\ket{1} \\
&= \tfrac{3}{5}\ket{1} + \tfrac{4}{5}\ket{0} \\
&= \tfrac{4}{5}\ket{0} + \tfrac{3}{5}\ket{1}
\end{aligned}
$$
:::

The full set of Pauli operators, along with the identity, form a complete basis for $2\times 2$ matrices, meaning we can write any operator as
$$
\mathcal O = aI + bX + cY + dZ,
$$
where $a$, $b$, $c$, and $d$ are complex numbers. We can extract each of these numbers, mathematically, with a trace operation
$$
\tr \mathcal O = 2a, \quad \tr \mathcal O X = 2b, \quad \tr \mathcal O Y = 2c, \quad \tr \mathcal O Z = 2d.
$$
Note that separately, $X$, $Y$, and $Z$ are Hermitian (and thus, observables). If $\mathcal O$ is an observable, then $\mathcal O = \mathcal O^\dagger$ immediately leads us to $a$, $b$, $c$, and $d$ being all real.

We can put constraints on these coefficients for unitary operators as well, and we leave this as an exercise for the reader.

Finally, these operators have eigenstates as well, and we can define them as $X\ket{\pm} = \pm \ket{\pm}$ and $Y\ket{\pm i} = \pm \ket{\pm i}$, and they have the forms
$$
\begin{aligned}
    \ket{\pm} & = \tfrac1{\sqrt2}(\ket 0 \pm \ket 1), \\
    \ket{\pm i} & = \tfrac1{\sqrt2}(\ket 0 \pm i \ket 1).
\end{aligned}
$$

We will often want to change our basis from $\ket{0}$ and $\ket{1}$ to $\ket{+}$ and $\ket{-}$. This is accomplished with something called the _Hadamard gate_ (we'll call it $H$, not to be confused with a Hamiltonian) and it is created specifically to change from computational basis to the $X$ basis: $H \ket{0} = \ket{+}$ and $H \ket{1} = \ket{-}$. As a matrix it takes the form
$$
H = \frac1{\sqrt{2}}\begin{bmatrix} 1 & 1 \\ 1 & -1 \end{bmatrix}.
$$

::: {.callout-important}
## The Power of Hadamard
The Hadamard gate is one of the most important gates in quantum computing with useful properties:

1. It creates equal superpositions from computational basis states.
2. It's its own inverse ($H^2 = I$)
3. It's used in nearly every quantum algorithm
4. When applied to $n$ qubits, it creates a superposition of all $2^n$ possible bit strings!
:::

::: {.callout-note icon="false"}
## **Example 3**: The Hadamard Transform
The Hadamard gate is particularly important because it creates superposition states. Let's see what happens when we apply it to $\ket{0}$:
$$
\begin{aligned}
H\ket{0} &= \frac{1}{\sqrt{2}}\begin{bmatrix} 1 & 1 \\ 1 & -1 \end{bmatrix}\begin{bmatrix} 1 \\ 0 \end{bmatrix} \\
&= \frac{1}{\sqrt{2}}\begin{bmatrix} 1 \\ 1 \end{bmatrix} \\
&= \frac{1}{\sqrt{2}}(\ket{0} + \ket{1}) \\
&= \ket{+}
\end{aligned}
$$
:::

## The Bloch sphere

The qubit itself is more than just a probability of being a 1 or a 0. A crucial bit of _quantum_ information is the relative phase between the two states for instance
$$
\ket{\psi} = \tfrac1{\sqrt2}( \ket 0 + e^{i\phi} \ket 1),
$$
and since all states are equivalent up to a _total_ phase, we can write the amplitude of each state with a real number. 
In this case, if we set $\ket{\psi} = x \ket{0} + y e^{i\phi} \ket 1$, then we have $\braket{\psi|\psi} = x^2 + y^2 = 1$ for normalization. This is the equation for a circle, and writing out $x = \cos(\theta/2)$ and $y = \sin(\theta/2)$[^3], we are lead to an angular representation of our state.
$$
\ket{\psi} = \cos(\theta/2) \ket{0} + \sin(\theta/2)e^{i\phi} \ket{1}.
$$ {#eq-bloch-sphere}
Let's see how this state relates to our Pauli operators. If we calculate the expectation values of each operator:

$$
\begin{aligned}
\langle X \rangle &= \bra{\psi}X\ket{\psi} \\
&= (\cos(\theta/2) \bra{0} + \sin(\theta/2)e^{-i\phi} \bra{1}) 
   X
   (\cos(\theta/2) \ket{0} + \sin(\theta/2)e^{i\phi} \ket{1}) \\
&= (\cos(\theta/2) \bra{0} + \sin(\theta/2)e^{-i\phi} \bra{1}) 
   (\cos(\theta/2) \ket{1} + \sin(\theta/2)e^{i\phi} \ket{0}) \\
&= \sin(\theta/2)\cos(\theta/2) e^{i\phi} + \cos(\theta/2)\sin(\theta/2)e^{-i\phi} \\
&= \sin(\theta/2)\cos(\theta/2) (e^{i\phi} + e^{-i\phi}) \\
&= 2\sin(\theta/2)\cos(\theta/2) \cos\phi \\
&= \sin \theta \cos\phi.
\end{aligned}
$$
We can carry out a similar calculation for $Y$ and $Z$ to obtain
$$
\begin{aligned}
\langle X \rangle &= \bra{\psi}X\ket{\psi} = \sin\theta\cos\phi \\
\langle Y \rangle &= \bra{\psi}Y\ket{\psi} = \sin\theta\sin\phi \\
\langle Z \rangle &= \bra{\psi}Z\ket{\psi} = \cos\theta
\end{aligned}
$$

These expectation values give us coordinates , which are precisely the coordinates of a point on a unit sphere! This is why we call it the Bloch sphere. The angles $\theta$ and $\phi$ are the usual spherical coordinates.

::: {.callout-note}
## The Bloch Sphere Geometry
- The north pole ($\theta=0$) corresponds to $\ket{0}$
- The south pole ($\theta=\pi$) corresponds to $\ket{1}$
- The equator ($\theta=\pi/2$) contains equal superposition of computational basis states:
  - $\phi=0$ gives $\ket{+}$ (positive x-axis)
  - $\phi=\pi$ gives $\ket{-}$ (negative x-axis)
  - $\phi=\pi/2$ gives $\ket{+i}$ (positive y-axis)
  - $\phi=3\pi/2$ gives $\ket{-i}$ (negative y-axis)
:::

::: {#fig-bloch-sphere}
```{.tikz}
%%| filename: bloch-sphere
%%| header-includes: \usetikzlibrary{arrows.meta}
%%| additionalPackages: \usepackage{braket}
\begin{tikzpicture}[scale=2]
    % Draw main circle
    \draw (0,0) circle (1);
    
    % Draw ellipse for perspective
    \draw[dashed] (0,0) ellipse (1 and 0.4);
    
    % Draw axes
    \draw[-{Latex[length=3mm]}] (-1.0,0) -- (1.0,0) node[below=2.5mm,left=1mm] {$y$};
    \draw[-{Latex[length=3mm]}] (0,-1.0) -- (0,1.0) node[right=2.5mm,below=1mm] {$z$};
    \draw[-{Latex[length=3mm]}] (0.7,0.3) -- (-0.7,-0.3) node[right=4mm] {$x$};
    
    % Label states
    % Z basis
    \node[above] at (0,1) {$\ket{0}$};
    \node[below] at (0,-1) {$\ket{1}$};
    
    % Y basis
    \node[right] at (1,0) {$\ket{+i}$};
    \node[left] at (-1,0) {$\ket{-i}$};
    
    % X basis
    \node[right=2mm, above=0.5mm] at (0.6,0.25) {$\ket{-}$};
    \node[below=2mm] at (-0.6,-0.25) {$\ket{+}$};
\end{tikzpicture}
```

The Bloch sphere showing eigenstates of X, Y, and Z Pauli operators
:::

::: {.callout-note icon="false"}
## Example: Hadamard Gate on $\ket{0}$
The Hadamard gate $H$ takes the state $\ket{0}$ (north pole) to $\ket{+}$ (on the equator at $\phi=0$). In terms of the Bloch sphere coordinates, this means:

- Starting point: $\theta=0$ (north pole)
- Ending point: $\theta=\pi/2$, $\phi=0$ (positive x-axis)

The gate effectively rotates the state by 90° around the y-axis. Similarly, $H\ket{1}$ takes the south pole to $\ket{-}$ on the negative x-axis.
:::

### General Unitary Rotations

The Hadamard example shows how unitary gates can rotate states on the Bloch sphere. More generally, any single-qubit unitary operation can be thought of as a rotation of the Bloch sphere. Let's see how this works.

A general rotation around a unit vector $\vec{n} = (n_x, n_y, n_z)$ by angle $\theta$ is given by
$$
R_{\vec{n}}(\theta) = \cos(\theta/2)I - i\sin(\theta/2)(n_xX + n_yY + n_zZ).
$$

For example:

- Rotation around z-axis: 
  $$ R_z(\theta) = e^{-i\theta Z/2} = \begin{bmatrix} e^{-i\theta/2} & 0 \\ 0 & e^{i\theta/2} \end{bmatrix} $$
- Rotation around x-axis: 
  $$ R_x(\theta) = e^{-i\theta X/2} = \begin{bmatrix} \cos(\theta/2) & -i\sin(\theta/2) \\ -i\sin(\theta/2) & \cos(\theta/2) \end{bmatrix} $$
- Rotation around y-axis: 
  $$R_y(\theta) = e^{-i\theta Y/2} = \begin{bmatrix} \cos(\theta/2) & -\sin(\theta/2) \\ \sin(\theta/2) & \cos(\theta/2) \end{bmatrix}$$

A remarkable fact is that any single-qubit unitary operation can be decomposed into three rotations around two different axes. This is known as the Euler angle decomposition:
$$
U = e^{i\alpha}R_z(\phi)R_y(\theta)R_z(\psi)
$$
where $\alpha$, $\phi$, $\theta$, and $\psi$ are real numbers. The global phase $e^{i\alpha}$ is often unimportant for quantum computing purposes.

::: {.callout-tip}
## Visualizing Rotations
The Euler angle decomposition has a nice geometric interpretation:

1. First rotation ($R_z(\psi)$): Rotate around z-axis
2. Second rotation ($R_y(\theta)$): Tilt to new latitude
3. Third rotation ($R_z(\phi)$): Rotate to final longitude
4. Global phase ($e^{i\alpha}$): Invisible in measurements

This is similar to how we specify points on Earth using latitude and longitude!
:::

### The Phase Gate

The phase gate (often denoted as $S$) is another important single-qubit gate that adds a phase of $i$ to the $\ket{1}$ state while leaving $\ket{0}$ unchanged:

$$
S = \begin{bmatrix} 1 & 0 \\ 0 & i \end{bmatrix}
$$

When acting on basis states:
$$
S\ket{0} = \ket{0}, \quad S\ket{1} = i\ket{1}
$$

The phase gate is equivalent to a $\pi/2$ rotation around the z-axis: $S = R_z(\pi/2)$. On the Bloch sphere, this corresponds to rotating a state by 90° around the z-axis.

::: {.callout-note icon=false}
## **Example**: Phase Gate on Superposition
Let's see what happens when we apply $S$ to an equal superposition state:

$$
\begin{aligned}
S\ket{+} &= S\left(\frac{1}{\sqrt{2}}(\ket{0} + \ket{1})\right) \\
&= \frac{1}{\sqrt{2}}(S\ket{0} + S\ket{1}) \\
&= \frac{1}{\sqrt{2}}(\ket{0} + i\ket{1})
\end{aligned}
$$

This transforms $\ket{+}$ into $\ket{+i}$, rotating it from the positive x-axis to the positive y-axis on the Bloch sphere.
:::

The phase gate is particularly important in quantum error correction and quantum algorithms where controlled phase operations are needed. 

More generically, we can create any $R_z(\phi)$ gate to perform rotations about the $z$-axis (this is very useful for Shor's algorithm). However, a common variant is the $T$ gate, which is simply $R_z(\pi/4)$ and is one of the minimal components needed to achieve universal quantum computation.

::: {.callout-important}
## Phase gate leaves computational basis states alone
Note that these gates only change superposition of computational basis states, so $S \ket{0} = \ket{0}$ and $S\ket{1} = i \ket{1}$. (Similarly for any gate made from rotations about the z-axis.)
:::

## Quantum Circuits

Now that we've covered the key single-qubit operations, we can start to think about how to represent sequences of these operations graphically using quantum circuits. In quantum circuits:

- Qubits are represented as horizontal lines (called "wires", see @fig-single-qubit).
- Gates are boxes or symbols placed on these wires (see @fig-qubit-XZ-gates and @fig-qubit-HS-gates).
- Time flows from left to right.
- Measurements are represented by meters (see @fig-qubit-measure).

Often, unless we are preparing a specific state for an algorithm, we may leave off the states from the ends of the "wire." This wire, @fig-single-qubit, you can think of as the identity.

::: {#fig-single-qubit layout-ncol=3}

```{.tikz}
%%| filename: qubit-identity-0
%%| caption: Identity on $\ket{0}$
%%| header-includes: \usetikzlibrary{quantikz2}
%%| additionalPackages: \usepackage{braket}
\begin{quantikz}
\lstick{$\ket{0}$} &&&&& \rstick{$\ket{0}$}
\end{quantikz}
```

```{.tikz}
%%| filename: qubit-identity-1
%%| caption: Identity on $\ket{1}$
%%| header-includes: \usetikzlibrary{quantikz2}
%%| additionalPackages: \usepackage{braket}
\begin{quantikz}
\lstick{$\ket{1}$} &&&&& \rstick{$\ket{1}$}
\end{quantikz}
```

```{.tikz}
%%| filename: qubit-identity
%%| caption: Identity on $\ket{\psi}$
%%| header-includes: \usetikzlibrary{quantikz2}
%%| additionalPackages: \usepackage{braket}
\begin{quantikz}
\lstick{$\ket{\psi}$} &&&&& \rstick{$\ket{\psi}$}
\end{quantikz}
```

Lines representing the evolution of a qubit (no gates applied)
::: 

While in quantum state evolution we apply operators right-to-left, the two operations $X \ket{0} = \ket{1}$ and $Z \ket{+} = \ket{-}$ are represented in @fig-qubit-XZ-gates.

::: {.callout-important}
The Pauli operators are both unitary and Hermitian, so they operator both as good quantum gates (which require unitary as @sec-postulate-unitary stipulates) and as good observables (as @sec-postulate-observable stipulates).
:::

::: {#fig-qubit-XZ-gates layout-ncol=2}

```{.tikz}
%%| filename: qubit-X-gate
%%| caption: Application of the $X$ gate.
%%| header-includes: \usetikzlibrary{quantikz2}
%%| additionalPackages: \usepackage{braket}
\begin{quantikz}
\lstick{$\ket{0}$} && \gate{X} && \rstick{$\ket{1}$}
\end{quantikz}
```

```{.tikz}
%%| filename: qubit-Z-gate
%%| caption: Application of the $Z$ gate.
%%| header-includes: \usetikzlibrary{quantikz2}
%%| additionalPackages: \usepackage{braket}
\begin{quantikz}
\lstick{$\ket{+}$} && \gate{Z} && \rstick{$\ket{-}$}
\end{quantikz}
```

Examples of the Pauli operators as gates.
::: 

The Hadamard and phase gates can also be mixed in, @fig-qubit-HS-gates, and we can even introduce the meter symbol for measurements, @fig-qubit-measure.

::: {#fig-qubit-HS-gates layout-ncol=2}

```{.tikz}
%%| filename: qubit-H-gate
%%| caption: Application of the Hadamard gate 
%%| header-includes: \usetikzlibrary{quantikz2}
%%| additionalPackages: \usepackage{braket}
\begin{quantikz}
\lstick{$\ket{0}$} && \gate{H} && \rstick{$\ket{+}$}
\end{quantikz}
```

```{.tikz}
%%| filename: qubit-S-gate
%%| caption: Application of the phase gate
%%| header-includes: \usetikzlibrary{quantikz2}
%%| additionalPackages: \usepackage{braket}
\begin{quantikz}
\lstick{$\ket{+}$} && \gate{S} && \rstick{$\ket{+i}$}
\end{quantikz}
```

Examples of the Hadamard and phase gates.
::: 

::: {#fig-qubit-measure layout-ncol=2}

```{.tikz}
%%| filename: qubit-X-gate-measure
%%| caption: Will measure 1 with 100% probability
%%| header-includes: \usetikzlibrary{quantikz2}
%%| additionalPackages: \usepackage{braket}
\begin{quantikz}
\lstick{$\ket{0}$} && \gate{X} && \meter{}
\end{quantikz}
```

```{.tikz}
%%| filename: qubit-H-gate-measure
%%| caption: Will measure 1 with 50% probability
%%| header-includes: \usetikzlibrary{quantikz2}
%%| additionalPackages: \usepackage{braket}
\begin{quantikz}
\lstick{$\ket{0}$} && \gate{H} && \meter{}
\end{quantikz}
```

Examples of measurements. The meter is assumed to be measuring in the computational basis unless otherwise noted (i.e., measuring the $Z$ operator).
::: 

Whenever measurements are performed, we will often transform to the computational basis $\ket{0}$ and $\ket{1}$ to perform a measurement.
By playing tricks with unitary transformations, we can measure other observables by mixing unitaries and measurements of the computational basis; dependent on the platform, this may or may not be necessary. 
In terms of diagrams, you should assume meters are measurements in the computational basis unless it is noted otherwise.


::: {.callout-note}
## Reading Quantum Circuits
Quantum circuits are read from left to right, just like reading text. Each horizontal line represents a qubit's journey through time, and the boxes show what operations happen and when.

The measurement symbol at the end indicates when we extract classical information from our quantum system.
:::

These diagrams give us a powerful visual language for describing quantum computations. Even complex algorithms can be broken down into sequences of these basic operations.

## Qubits in quantum technology

A large part of the course will consist of finding physical systems where we can identify certain states as $\ket{0}$ and $\ket{1}$, and then proceed to figure out how to perform the gates we need for quantum algorithms. In this way, this course could be called "two-level systems and where to find them."

However, algorithms need these qubits to talk to each other, so we will now proceed to two qubits, and beyond!


[^1]: Magic is a technical term in quantum computing, though we're using it in a colloquial sense here, see @BravyiKitaev2005.
[^2]: In some literature, these are matrices are denoted by $\sigma_{x}$, $\sigma_y$, and $\sigma_z$ and related to spin operators via $S_i =\frac12 \sigma_i$. This insight can help bridge the idea of these operators and the Bloch sphere.
[^3]: The divide-by-two for the angles will become clear as we go through this section.
